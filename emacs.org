My emacs config

#+PROPERTY: HEADER-ARGS+ :comments no :tangle emacs.el

* Bootstrapping
** Straight
#+BEGIN_SRC emacs-lisp
(defvar bootstrap-version)
(setq straight-repository-branch "develop")
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))

(straight-use-package 'use-package)
#+END_SRC

** Package-list
#+BEGIN_SRC emacs-lisp
(require 'package)
(let* ((no-ssl (and (memq system-type '(windows-nt ms-dos))
                    (not (gnutls-available-p))))
       (proto (if no-ssl "http" "https")))
  (when no-ssl
    (warn "\
Your version of Emacs does not support SSL connections,
which is unsafe because it allows man-in-the-middle attacks.
There are two things you can do about this warning:
1. Install an Emacs version that does support SSL and be safe.
2. Remove this warning from your init file so you won't see it again."))
  ;; Comment/uncomment these two lines to enable/disable MELPA and MELPA Stable as desired
  (add-to-list 'package-archives (cons "melpa" (concat proto "://melpa.org/packages/")) t)
  ;;(add-to-list 'package-archives (cons "melpa-stable" (concat proto "://stable.melpa.org/packages/")) t)
  (when (< emacs-major-version 24)
    ;; For important compatibility libraries like cl-lib
    (add-to-list 'package-archives (cons "gnu" (concat proto "://elpa.gnu.org/packages/")))))
(package-initialize)
#+END_SRC

* Evil
#+BEGIN_SRC emacs-lisp
(use-package evil
  :straight t
  :init
  (setq evil-want-C-u-scroll t
        ; Warning (evil-collection): Make sure to set
        ; `evil-want-keybinding' to nil before loading evil or
        ; evil-collection.  See
        ; https://github.com/emacs-evil/evil-collection/issues/60 for
        ; more details.
        evil-want-keybinding nil)
  (define-key global-map (kbd "C-i") 'universal-argument)
  (define-key universal-argument-map (kbd "C-i") 'universal-argument-more)
  :config
  (evil-mode 1)
  (global-unset-key (kbd "C-x +")) ; Set to "C-w =" with evil

  (defun ibizaman/toggle-value (sym)
    "Toggle SYM assuming it is a boolean."
    (set sym (not (symbol-value sym))))


  (defun ibizaman/evil-collection-imenu-setup ()
  "Set up `evil' bindings for `imenu'."
  (evil-define-key 'normal 'global
      "gt" 'counsel-semantic-or-imenu))

  (ibizaman/evil-collection-imenu-setup)
  )

(use-package evil-collection
  :straight t
  :after evil
  :config
  (evil-collection-init))

(use-package evil-textobj-syntax
  :straight t)

(use-package evil-textobj-column
  :straight t
  :bind (:map evil-inner-text-objects-map
         ("c" . evil-textobj-column-word)
         ("C" . evil-textobj-column-WORD)))

(use-package evil-numbers
  :straight t
  :bind (("C-c +" . evil-numbers/inc-at-pt)
         ("C-c -" . evil-numbers/dec-at-pt)))
#+END_SRC

#+RESULTS:
: evil-numbers/dec-at-pt

* System
** Mac
#+BEGIN_SRC emacs-lisp
(setq mac-function-key-is-meta t)
(setq mac-function-modifier 'meta)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :straight t
    :config
    (when (memq window-system '(mac ns x))
      (exec-path-from-shell-initialize)))
#+END_SRC

* Helpers
#+BEGIN_SRC emacs-lisp
(defun ibizaman/define-keymap (map-symbol keys)
  (set map-symbol
        (let ((map (make-sparse-keymap)))
          (dolist (key keys)
                  (define-key map (car key) (cdr key)))
          map)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun completing-read-simple (prompt alist)
  "Equivalent to (completing-read PROMPT ALIST nil nil (car ALIST) (quote ALIST))."
  (completing-read prompt (symbol-value alist) nil nil nil alist))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun call-with-prefix (prefix function)
  "Call a function interactively like if \\<keymap> PREFIX FUNCTION was given."
  (interactive)
  (let ((current-prefix-arg (list prefix)))
    (call-interactively function)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun insert-under (&rest forms)
  (save-excursion
    (move-end-of-line 1)
    (insert (format "\n%s" forms))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun ibizaman/relevant-directory ()
  "Return the relevant directory for current buffer."
  (or default-directory
      (buffer-file-name (current-buffer))))

(defun ibizaman/project-root ()
  "Get project root, if any."
    (if-let ((dir (ibizaman/relevant-directory))
             (git-root (vc-git-root dir)))
        git-root
      nil))

(defun ibizaman/find-in-project-root-regexp (regexp)
  "Find files matching REGEXP in root directory."
  (let ((root-dir (ibizaman/project-root)))

    (when (not root-dir)
      (error "No project root"))

    (mapcar
     (lambda (el) (file-relative-name el root-dir))
     (directory-files-recursively root-dir regexp))))
#+END_SRC

** Expand region
#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :straight t
  :bind (("C-c =" . er/expand-region)
	 ("C-c -" . (lambda () (interactive) (call-with-prefix -1 'er/expand-region)))))

(defun use-region-or-expand-region ()
  "Use region if active or expand region at point."
  (when (not (use-region-p))
    (let ((inhibit-message t))
      (call-interactively 'er/expand-region))))
#+END_SRC

** Compilation
#+BEGIN_SRC emacs-lisp
(defun get-region-or-line-content ()
  "Get region or line content."
  (if (use-region-p)
    (buffer-substring-no-properties (region-beginning) (region-end))
    (thing-at-point 'line t)))


(defun compile-region-or-line ()
  "Compile region or line content."
  (interactive)
  (compile (get-region-or-line-content) t))


(global-set-key (kbd "C-c s") 'compile-region-or-line)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(define-key text-mode-map (kbd "C-c C-k") #'kill-current-buffer)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun ibizaman/compile-at-dir (dir)
  "Ask for DIR before calling `compile'."
  (interactive (list
                (read-directory-name "Directory to run comman in: " "~" nil t (file-name-directory (directory-file-name (magit-git-dir))))))
  (let ((default-directory dir))
    (universal-argument)
    (call-interactively 'compile)))
#+END_SRC

* General
** Temp directory
#+BEGIN_SRC emacs-lisp
(make-directory "~/.emacs.d/tmp" t)
(setq temporary-file-directory (expand-file-name "~/.emacs.d/tmp"))
#+END_SRC

** Whitespace
#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

** Saving buffers
Enable saving of minibuffer history and other variables

#+BEGIN_SRC emacs-lisp
(setq savehist-additional-variables '(kill-ring search-ring regexp-search-ring)
      savehist-file "~/.emacs.d/savehist")
(savehist-mode t)
#+END_SRC

** Auto set executable
When saving a file that starts with `#!', make it executable.
#+BEGIN_SRC emacs-lisp
(add-hook 'after-save-hook
	  'executable-make-buffer-file-executable-if-script-p)
#+END_SRC

** Startup
Start frames maximized
#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(fullscreen . maximized))
#+END_SRC

** Font
From [[https://valignatev.com/posts/emacs-font/]]
#+BEGIN_SRC emacs-lisp
(setq my-font-name "Inconsolata")
(defcustom my-font-size 13 "My font size")

(defun set-frame-font-size (&optional font-size)
  "Change frame font size to FONT-SIZE.
If no FONT-SIZE provided, reset the size to its default variable."
  (let ((font-size
     (or font-size
       (car (get 'my-font-size 'standard-value)))))
    (customize-set-variable 'my-font-size font-size)
    (set-frame-font
     (format "%s %d" my-font-name font-size) nil t)))

(set-face-attribute 'default nil :family "Inconsolata"
                               :foundry "PfEd"
                               :slant 'normal
                               :height 130
                               :weight 'normal
                               :width 'normal)

(defun increase-frame-font ()
  "Increase frame font by one."
  (interactive)
  (set-frame-font-size (+ my-font-size 1)))

(defun decrease-frame-font ()
  "Decrease frame font by one."
  (interactive)
  (set-frame-font-size (- my-font-size 1)))

(defun reset-frame-font ()
  "Reset frame font to its default value."
  (interactive)
  (set-frame-font-size))

(global-set-key (kbd "C-x C-=") #'increase-frame-font)
(global-set-key (kbd "C-x C--") #'decrease-frame-font)
(global-set-key (kbd "C-x C-0") #'reset-frame-font)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package command-log-mode
  :straight (command-log-mode :type git :host github :repo "ibizaman/command-log-mode" :branch "master"))
#+END_SRC

** Customization
#+BEGIN_SRC emacs-lisp
; Move custom-set-variables and custom-set-faces in different file
(setq custom-file "~/.emacs-custom.el")
(load custom-file)

; Prompt to save customization before quitting
(add-hook 'kill-emacs-query-functions
	  'custom-prompt-customize-unsaved-options)

(setq backup-directory-alist `(("." . "~/.saves")))

(use-package helpful
  :straight t
  :bind (("C-h f" . #'helpful-callable)
         ("C-h v" . #'helpful-variable)
         ("C-h k" . #'helpful-key)))

(progn
  (global-set-key (kbd "C-h V") #'customize-variable)
  (global-set-key (kbd "C-h G") #'customize-group))
#+END_SRC

** Disable GUI
#+BEGIN_SRC emacs-lisp
(menu-bar-mode 0)
(tool-bar-mode 0)
(when (fboundp 'scroll-bar-mode)
  (scroll-bar-mode 0))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)

(column-number-mode 1)
(setq mode-line-position
      '(;; %p print percent of buffer above top of window, o Top, Bot or All
        ;; (-3 "%p")
        ;; %I print the size of the buffer, with kmG etc
        ;; (size-indication-mode ("/" (-4 "%I")))
        ;; " "
        ;; %l print the current line number
        ;; %c print the current column
        (line-number-mode ("%l" (column-number-mode ":%c")))
        (:eval (flycheck-mode-line-status-text))
        ))

(use-package flycheck-color-mode-line
  :straight t
  :config
  (add-hook 'flycheck-mode-hook 'flycheck-color-mode-line-mode))
#+END_SRC

** Keyfreq
#+BEGIN_SRC emacs-lisp
(use-package keyfreq
  :straight t
  :config
  (keyfreq-mode 1)
  (keyfreq-autosave-mode 1))
#+END_SRC

** Parenthesis
#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :straight t
  :init
  (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))

; TODO: not in org-mode
(use-package highlight-parentheses
  :straight t
  :config
  (global-highlight-parentheses-mode))
#+END_SRC

** Ibuffer
#+BEGIN_SRC emacs-lisp
(use-package ibuffer
  :straight t
  :bind (("C-x C-b" . 'ibuffer)))
#+END_SRC

** Completion
#+BEGIN_SRC emacs-lisp
(use-package ivy
  :straight t
  :after magit
  :init (global-unset-key (kbd "C-x f"))
  :bind (("C-s" . 'swiper)
         ("C-x f f" . 'ibizaman/counsel-git-default)
         ("C-x f g" . 'ibizaman/counsel-git-grep-default))
  :config
  (ivy-mode 1)
  (setq ivy-use-virtual-buffers t)
  (setq ivy-count-format "(%d/%d) ")
  (setq ivy-re-builders-alist
        '((t . ivy--regex-ignore-order)))
  (setq magit-completing-read-function 'ivy-completing-read))

(defun ibizaman/counsel-git-default ()
  "Find file in the current relevant directory with word at point by default."
  (interactive)
  (let ((search-term (thing-at-point 'word t)))
    (if-let ((dir (ibizaman/relevant-directory))
             (git-root (vc-git-root dir)))
        (counsel-git search-term)
      (counsel-file-jump search-term (read-directory-name "Root for finding file: ")))))

(defun ibizaman/counsel-git-grep-default ()
  "Grep for a string in the current relevant directory with word at point by default."
  (interactive)
  (let ((search-term (thing-at-point 'word t)))
    (if-let ((dir (ibizaman/relevant-directory))
             (git-root (vc-git-root dir)))
        (counsel-git-grep nil search-term)
      (let ((default-directory (read-directory-name "Root for grepping: ")))
        (counsel-grep search-term)))))

(use-package counsel
  :straight t
  :after ivy
  :config
  (counsel-mode 1))
#+END_SRC

** Emojify
#+BEGIN_SRC emacs-lisp
(use-package emojify
  :straight t)
#+END_SRC

** Ediff
#+BEGIN_SRC emacs-lisp
(defun ediff-buffer-mode-next-difference ()
  "Advance to the next difference."
  (interactive)
  (with-selected-window
      (get-buffer-window "*Ediff Control Panel*")
    (ediff-next-difference)))


(defun ediff-buffer-mode-previous-difference ()
  "Advance to the previous difference."
  (interactive)
  (with-selected-window
      (get-buffer-window "*Ediff Control Panel*")
    (ediff-previous-difference)))


(defun ediff-buffer-mode--get-current-buffer-char ()
  "Get char corresponding to current Ediff buffer."
  (let ((buff (current-buffer)))
    (with-selected-window
        (get-buffer-window "*Ediff Control Panel*")
      (cond ((eq buff ediff-buffer-A) ?a)
            ((eq buff ediff-buffer-B) ?b)
            ((eq buff ediff-buffer-C) ?c)))))


(defun ediff-buffer-mode--get-other-buffer-char (current-buffer-char)
  "For CURRENT-BUFFER-CHAR return other buffer chars."
  (remove current-buffer-char '(?a ?b ?c)))


(defun ediff-buffer-mode--prompt-other-source (current-buffer-char get-or-put)
  "For CURRENT-BUFFER-CHAR, prompt user for other buffer source with prompt adapting to GET-OR-PUT value."
  (let* ((prompt (if (string= get-or-put "get") "Select buffer to get changes from: "
                   "Select buffer to put changes to: "))
         (buffer-help (if (string= get-or-put "get") "Get from "
                        "Put to "))
         (choice
          (read-multiple-choice
           prompt
           (mapcar
            (lambda (char) (list char (concat buffer-help (string char))))
            (ediff-buffer-mode--get-other-buffer-char current-buffer-char)))))
    (car choice)))


(defun ediff-buffer-mode--validate-other-source (current-buffer-char other-buffer-char)
  "For CURRENT-BUFFER-CHAR, check OTHER-BUFFER-CHAR is an accepted char.

For example, for CURRENT-BUFFER-CHAR = ?a then the accepted chars are ?b and ?c."
  (let ((accepted-other-buffers (ediff-buffer-mode--get-other-buffer-char current-buffer-char)))
    (when (not (member other-buffer-char accepted-other-buffers))
      (error "Chosen buffer must be %s" (mapconcat (lambda (x) (string x)) accepted-other-buffers " or ")))))


(defun ediff-buffer-mode-get-changes (&optional get-src)
  "Get changes from the other window into the current window.

For 3-way jobs, the other window cannot be determined automatically.
In that case a prompt will ask the user to enter what buffer the change must come
from.  If GET-SRC is given, use that as the source and do not prompt the user."
  (interactive)
  (let ((buff-char (ediff-buffer-mode--get-current-buffer-char)))
    (with-selected-window
        (get-buffer-window "*Ediff Control Panel*")
      (if ediff-3way-job
          (progn
            (let* ((other-buff-char (ediff-buffer-mode--get-other-buffer-char buff-char))
                   (get-src (or get-src (ediff-buffer-mode--prompt-other-source buff-char "get"))))
              (ediff-buffer-mode--validate-other-source buff-char get-src)
              (cond ((and (char-equal buff-char ?a) (char-equal get-src ?b)) (ediff-copy-B-to-A nil))
                    ((and (char-equal buff-char ?a) (char-equal get-src ?c)) (ediff-copy-C-to-A nil))
                    ((and (char-equal buff-char ?b) (char-equal get-src ?a)) (ediff-copy-A-to-B nil))
                    ((and (char-equal buff-char ?b) (char-equal get-src ?c)) (ediff-copy-C-to-B nil))
                    ((and (char-equal buff-char ?c) (char-equal get-src ?a)) (ediff-copy-A-to-C nil))
                    ((and (char-equal buff-char ?c) (char-equal get-src ?b)) (ediff-copy-B-to-C nil)))))
        (progn
          (cond (char-equal buff-char ?a) (ediff-copy-B-to-A nil)
                (char-equal buff-char ?b) (ediff-copy-A-to-B nil)))))))


(defun ediff-buffer-mode-put-changes (&optional put-src)
  "Get changes from the other window into the current window.

For 3-way jobs, the other window cannot be determined automatically.
In that case a prompt will ask the user to enter what buffer the change must come
from.  If PUT-SRC is given, use that as the source and do not prompt the user."
  (interactive)
  (let ((buff-char (ediff-buffer-mode--get-current-buffer-char)))
    (with-selected-window
        (get-buffer-window "*Ediff Control Panel*")
      (if ediff-3way-job
          (progn
            (let* ((other-buff-char (ediff-buffer-mode--get-other-buffer-char buff-char))
                   (put-src (or put-src (ediff-buffer-mode--prompt-other-source buff-char "put"))))
              (ediff-buffer-mode--validate-other-source buff-char put-src)
              (cond ((and (char-equal buff-char ?a) (char-equal put-src ?b)) (ediff-copy-A-to-B nil))
                    ((and (char-equal buff-char ?a) (char-equal put-src ?c)) (ediff-copy-A-to-C nil))
                    ((and (char-equal buff-char ?b) (char-equal put-src ?a)) (ediff-copy-B-to-A nil))
                    ((and (char-equal buff-char ?b) (char-equal put-src ?c)) (ediff-copy-B-to-C nil))
                    ((and (char-equal buff-char ?c) (char-equal put-src ?a)) (ediff-copy-C-to-A nil))
                    ((and (char-equal buff-char ?c) (char-equal put-src ?b)) (ediff-copy-C-to-B nil)))))
        (progn
          (cond ((char-equal buff-char ?a) (ediff-copy-A-to-B nil))
                ((char-equal buff-char ?b) (ediff-copy-B-to-A nil))))))))


(defvar ediff-buffer-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "C-j") 'ediff-buffer-mode-next-difference)
    (define-key map (kbd "C-k") 'ediff-buffer-mode-previous-difference)
    (define-key map (kbd "C-c o") 'ediff-buffer-mode-get-changes)
    (define-key map (kbd "C-c p") 'ediff-buffer-mode-put-changes)
    map))


(define-minor-mode ediff-buffer-mode
  "Minor mode enabled on buffers used in Ediff."
  :init-value nil)


(defun enable-ediff-buffer-mode ()
  "Enable ediff=buffer-mode."
  (ediff-buffer-mode t))


(defun disable-all-ediff-buffer-mode ()
  "Enable ediff=buffer-mode."
  (with-selected-window
      (get-buffer-window "*Ediff Control Panel*")
    (if ediff-buffer-A
        (with-selected-window (get-buffer-window ediff-buffer-A)
          (ediff-buffer-mode -1)))
    (if ediff-buffer-B
        (with-selected-window (get-buffer-window ediff-buffer-B)
          (ediff-buffer-mode -1)))
    (if ediff-buffer-C
        (with-selected-window (get-buffer-window ediff-buffer-C)
          (ediff-buffer-mode -1)))))


(add-hook 'ediff-prepare-buffer-hook 'enable-ediff-buffer-mode)
(add-hook 'ediff-cleanup-hook 'disable-all-ediff-buffer-mode)
#+END_SRC

Always expand org file when diffing them
[[https://www.reddit.com/r/emacs/comments/b7at5a/how_to_magit_diff_in_org_files/ejqox3j/]]
#+BEGIN_SRC emacs-lisp
(add-hook 'ediff-prepare-buffer-hook #'show-all)
#+END_SRC

** Occur
#+BEGIN_SRC emacs-lisp
(progn
  (defun occur-dwim ()
    "Call `occur' with the symbol under point or selected region as default."
    (interactive)
    (push (if (region-active-p)
              (buffer-substring-no-properties
               (region-beginning)
               (region-end))
            (let ((sym (thing-at-point 'symbol)))
              (when (stringp sym)
                (regexp-quote sym))))
          regexp-history)
    (call-interactively 'occur))

  ;; Focus on *Occur* window right away.
  (add-hook 'occur-hook (lambda () (other-window 1)))

  (defun reattach-occur ()
    (if (get-buffer "*Occur*")
        (switch-to-buffer-other-window "*Occur*")
      (hydra-occur-dwim/body) ))

  (global-set-key (kbd "M-s o") 'occur-dwim))
#+END_SRC

** Compilation
#+BEGIN_SRC emacs-lisp
(defun ibizaman/compilation-buffer-name (name-of-mode)
  (let ((prefix (concat "*" (downcase name-of-mode) " ")))
    (if (string-prefix-p prefix (buffer-name))
        (buffer-name)
      (concat prefix (buffer-name) "*"))))

(setq compilation-buffer-name-function #'ibizaman/compilation-buffer-name)
#+END_SRC

** Highlight Symbol
#+BEGIN_SRC emacs-lisp
(use-package auto-highlight-symbol
  :straight t
  :config
  (global-auto-highlight-symbol-mode 1)
  :bind (("M-p" . ahs-backward)
         ("M-n" . ahs-forward)
         ("M-S-p" . ahs-backward-definition)
         ("M-S-n" . ahs-forward-definition)))
#+END_SRC

** Split shell
#+BEGIN_SRC emacs-lisp
(use-package bifocal
  :straight t
  :config
  (bifocal-global-mode 1))
#+END_SRC
** Dired Sidebar
#+BEGIN_SRC emacs-lisp
(use-package dired-sidebar
  :straight t
  :commands (dired-sidebar-toggle-sidebar)
  :bind (("C-c C-d" . dired-sidebar-toggle-sidebar)
         :map org-mode-map
         ("C-c C-d" . dired-sidebar-toggle-sidebar)))
#+END_SRC

** Processes
#+BEGIN_SRC emacs-lisp
(defun ibizaman/process-menu-add-bindings()
  "Add bindings to process-menu-mode."
    (define-key process-menu-mode-map (kbd "g r") 'list-processes)
    (define-key process-menu-mode-map (kbd "x") 'process-menu-delete-process)
    (evil-define-key 'normal process-menu-mode-map (kbd "x") 'process-menu-delete-process))

(add-hook 'process-menu-mode-hook 'ibizaman/process-menu-add-bindings)
#+END_SRC

** Info
#+BEGIN_SRC emacs-lisp
(global-evil-collection-unimpaired-mode -1)
(evil-collection-unimpaired-mode -1)
(evil-define-key 'normal Info-mode-map (kbd "]") #'Info-forward-node)
(evil-define-key 'normal Info-mode-map (kbd "[") #'Info-backward-node)
#+END_SRC

* Org

** Configure
#+BEGIN_SRC emacs-lisp
(use-package org
  :straight t
  :after (evil es-mode)
  :init
  (defun my/org-mode-hook-evil ()
      (setq evil-auto-indent nil))
  (add-hook 'org-mode-hook 'my/org-mode-hook-evil)
  :config
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (sql . t)
     (python . t)
     (shell . t)
     (dot . t)
     (elasticsearch . t)))

  (org-babel-lob-ingest "~/.vim/emacs-lob.org")

  (progn
    (defun ibizaman/org-copy-element ()
      (interactive)
      (let* ((elem (org-element-at-point))
             (beg (org-element-property :begin elem))
             (end (org-element-property :end elem)))
        (copy-region-as-kill beg end)
        (goto-char end))))

  (setq org-log-done 'time)

  (add-hook 'org-capture-prepare-finalize-hook 'org-id-store-link)

  (evil-define-key 'normal org-mode-map (kbd "<tab>") 'org-cycle)
  :bind (("C-c j" . outline-next-heading)
         ("C-c k" . outline-previous-heading)
         ("C-c h" . outline-up-heading)
         ("C-c l" . outline-show-subtree)
         ("C-c c" . org-capture)
         ("C-c C-l" . org-store-link)
         :map org-mode-map
         ("C-c o d" . org-cut-element)
         ("C-c o c" . ibizaman/org-copy-element)
         ("<tab>" . org-cycle)))

#+END_SRC

** Babel
#+BEGIN_SRC emacs-lisp
(use-package ob-async
  :straight t
  :after org)

(use-package ob-python
  :after org)

(use-package ob-shell
  :after org)

(use-package ob-tmux
  :straight (ob-tmux :type git :host nil :repo "https://github.com/ahendriksen/ob-tmux.git")
  :config
  (setq org-babel-default-header-args:tmux
        '((:results . "silent")
          (:terminal . "iterm")))
  (setq org-babel-tmux-session-prefix "ob-"))

#+END_SRC

*** Lang=Conf
Expand variables in conf files.

Inspired from [[file:~/.emacs.d/straight/repos/org/lisp/ob-sql.el::(defun%20org-babel-expand-body:sql%20(body%20params)%20"Expand%20BODY%20according%20to%20the%20values%20of%20PARAMS."%20(org-babel-sql-expand-vars%20body%20(org-babel--get-vars%20params)))][orb-babel-expand-body:sql]] that calls internally [[file:~/.emacs.d/straight/repos/org/lisp/ob-sql.el::(defun%20org-babel-sql-expand-vars%20(body%20vars)%20"Expand%20the%20variables%20held%20in%20VARS%20in%20BODY."%20(mapc%20(lambda%20(pair)%20(setq%20body%20(replace-regexp-in-string%20(format%20"$%25s"%20(car%20pair))%20(let%20((val%20(cdr%20pair)))%20(if%20(listp%20val)%20(let%20((data-file%20(org-babel-temp-file%20"sql-data-")))%20(with-temp-file%20data-file%20(insert%20(orgtbl-to-csv%20val%20'(:fmt%20(lambda%20(el)%20(if%20(stringp%20el)%20el%20(format%20"%25S"%20el)))))))%20data-file)%20(if%20(stringp%20val)%20val%20(format%20"%25S"%20val))))%20body)))%20vars)%20body)][org-babel-sql-expand-vars]]:
#+BEGIN_EXAMPLE emacs-lisp
(defun org-babel-expand-body:sql (body params)
  "Expand BODY according to the values of PARAMS."
  (org-babel-sql-expand-vars
   body (org-babel--get-vars params)))

(defun org-babel-sql-expand-vars (body vars)
  "Expand the variables held in VARS in BODY."
  (mapc
   (lambda (pair)
     (setq body
	   (replace-regexp-in-string
	    (format "$%s" (car pair))
	    (let ((val (cdr pair)))
              (if (listp val)
                  (let ((data-file (org-babel-temp-file "sql-data-")))
                    (with-temp-file data-file
                      (insert (orgtbl-to-csv
                               val '(:fmt (lambda (el) (if (stringp el)
                                                      el
                                                    (format "%S" el)))))))
                    data-file)
                (if (stringp val) val (format "%S" val))))
	    body)))
   vars)
  body)
#+END_EXAMPLE

TODO: propose this as an enhancement
#+BEGIN_SRC emacs-lisp
(defun org-babel-expand-body:conf (body params)
  "Expand BODY according to the values of vars inside PARAMS.

Values in the form $symbol are expanded to their value from `:var symbol \"value\"'."
  (mapc
   (lambda (pair)
     (setq body
	   (replace-regexp-in-string
	    (format "$%s" (car pair))
	    (let ((val (cdr pair)))
              (cond ((stringp val) val)
                    (t (format "%S" val))))
            body)))
   (org-babel--get-vars params))
  body)
#+END_SRC

** Export
#+BEGIN_SRC emacs-lisp
(use-package ox-hugo
  :straight t
  :after ox)
#+END_SRC

** Capture
No need to start the server manually here as we use a daemon:
[[id:498ba909-6d1b-44a6-b583-afb406d6347f][dots.org/Emacs]]


*** Protocol
:PROPERTIES:
:HEADER-ARGS: :tangle no
:END:
Inspired from https://orgmode.org/worg/org-contrib/org-protocol.html

#+BEGIN_SRC emacs-lisp
(use-package org-protocol)
#+END_SRC

Test (run outside of emacs):
#+BEGIN_SRC bash :results silent
emacsclient 'org-protocol://capture?template=t'
#+END_SRC

Download:
https://github.com/neil-smithline-elisp/EmacsClient.app
#+BEGIN_SRC bash
mkdir -p ~/tmp
#+END_SRC

#+BEGIN_SRC bash :dir ~/tmp
curl -LO https://github.com/neil-smithline-elisp/EmacsClient.app/raw/master/EmacsClient.zip
#+END_SRC

#+RESULTS:

#+BEGIN_SRC bash :dir ~/tmp
unzip EmacsClient.zip
#+END_SRC

#+RESULTS:
| Archive:   | EmacsClient.zip                                                 |
| creating:  | EmacsClient.app/                                                |
| creating:  | EmacsClient.app/Contents/                                       |
| creating:  | EmacsClient.app/Contents/.@/                                    |
| inflating: | EmacsClient.app/Contents/.@/Info.plist.~1~                      |
| inflating: | EmacsClient.app/Contents/.@/Info.plist.~2~                      |
| inflating: | EmacsClient.app/Contents/.@/Info.plist.~3~                      |
| inflating: | EmacsClient.app/Contents/.@/Info.plist.~4~                      |
| inflating: | EmacsClient.app/Contents/Info.plist                             |
| creating:  | EmacsClient.app/Contents/MacOS/                                 |
| inflating: | EmacsClient.app/Contents/MacOS/EmacsClient                      |
| inflating: | EmacsClient.app/Contents/PkgInfo                                |
| creating:  | EmacsClient.app/Contents/Resources/                             |
| inflating: | EmacsClient.app/Contents/Resources/applet.icns                  |
| inflating: | EmacsClient.app/Contents/Resources/applet.rsrc                  |
| creating:  | EmacsClient.app/Contents/Resources/description.rtfd/            |
| inflating: | EmacsClient.app/Contents/Resources/description.rtfd/TXT.rtf     |
| inflating: | EmacsClient.app/Contents/Resources/EmacsClient.icns             |
| creating:  | __MACOSX/                                                       |
| creating:  | __MACOSX/EmacsClient.app/                                       |
| creating:  | __MACOSX/EmacsClient.app/Contents/                              |
| creating:  | __MACOSX/EmacsClient.app/Contents/Resources/                    |
| inflating: | __MACOSX/EmacsClient.app/Contents/Resources/._EmacsClient.icns  |
| creating:  | EmacsClient.app/Contents/Resources/Scripts/                     |
| inflating: | EmacsClient.app/Contents/Resources/Scripts/main.scpt            |
| creating:  | __MACOSX/EmacsClient.app/Contents/Resources/Scripts/            |
| inflating: | __MACOSX/EmacsClient.app/Contents/Resources/Scripts/._main.scpt |

#+BEGIN_SRC bash :dir ~/tmp :results output
rsync -av EmacsClient.app /Applications
#+END_SRC

#+RESULTS:
: sending incremental file list
:
: sent 484 bytes  received 23 bytes  1,014.00 bytes/sec
: total size is 345,696  speedup is 681.85

#+BEGIN_SRC bash :dir ~/tmp :results output
open -a EmacsClient
#+END_SRC

Add bookmarklet:
#+BEGIN_SRC javascript
javascript:(function () {
    var l = 'org-protocol://capture?template=t' +
        '&url=' + encodeURIComponent(location.href) +
        '&title=' + encodeURIComponent(document.title || "[untitled page]") +
        '&body=' + encodeURIComponent(window.getSelection());
    console.log(l);
    location.href = l;
})();
#+END_SRC


** Links
Add links to customize groups and options:
#+BEGIN_SRC emacs-lisp
(require 'org)

(org-link-set-parameters "customize-option"
                         :follow #'org-store-link:customize-open-option
                         :store #'org-store-link:customize-store-link-option)

(org-link-set-parameters "customize-group"
                         :follow #'org-store-link:customize-open-group
                         :store #'org-store-link:customize-store-link-group)

(defun org-store-link:customize-open-option (path)
  "Visit the customize variable at PATH."
  (customize-option (intern path)))

(defun org-store-link:customize-open-group (path)
  "Visit the customize group at PATH."
  (customize-group (intern path)))

(defun org-store-link:customize-store-link-option ()
  "Store a link to a customize option."
  (org-store-link:customize--store-link 'option))

(defun org-store-link:customize-store-link-group ()
  "Store a link to a customize group."
  (org-store-link:customize--store-link 'group))

(defun org-store-link:customize--store-link (type)
  "Store a link to a customize TYPE window."
  (when (memq major-mode '(Custom-mode))
    (let* ((page (org-store-link:customize-get-page-name))
           (page-type (org-store-link:customize-get-page-type))
           (link-type (symbol-name page-type))
           (link (format "customize-%s:%s" link-type page))
           (description (format "Customize %s for %s" link-type page)))
      (when (eq page-type type)
        (org-store-link-props
         :type (format "customize-%s" link-type)
         :link link
         :description description)))))

(defun org-store-link:customize-get-page-type ()
  "Extract the page type (group or option) from the buffer name."
  (if (string-match "Customize \\(\\S-+\\):" (buffer-name))
      (pcase (match-string 1 (buffer-name))
        ("Group" 'group)
        ("Option" 'option))
    (error "Cannot create link to this customize page")))

(defun org-store-link:customize-get-page-name ()
  "Extract the page name from the buffer name."
  (if (string-match ": \\(.+\\)\\*" (buffer-name))
      (let* ((str (downcase (match-string 1 (buffer-name)))))
        (replace-regexp-in-string " " "-" str))
    (error "Cannot create link to this customize page")))
#+END_SRC

** Elsewhere
Packages to make org features available in non-org buffers.

#+BEGIN_SRC emacs-lisp
(use-package org-link-minor-mode
  :straight (org-link-minor-mode :type git :host github :repo "seanohalpin/org-link-minor-mode" :branch "master")
  :config
  (org-link-minor-mode))
#+END_SRC

* Eshell
#+BEGIN_SRC emacs-lisp
(use-package eshell
  :config
  (defun ibizaman/eshell-imenu-expression ()
    (setq-local imenu-generic-expression
                '(("Prompt" " $ \\(.*\\)" 1))))
  (add-hook 'eshell-mode-hook 'ibizaman/eshell-imenu-expression))
#+END_SRC

* Layout
#+BEGIN_SRC emacs-lisp
(winner-mode)
#+END_SRC

With truncate-lines, do not split word
#+BEGIN_SRC emacs-lisp
(setq visual-line-mode 1)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package mustang-theme
  :straight t)
#+END_SRC

** Modeline
#+BEGIN_SRC emacs-lisp
(defun shorten-directory (dir max-length)
  "Show up to `max-length' characters of a directory name `dir'."
  (let ((path (reverse (split-string (abbreviate-file-name dir) "/")))
               (output ""))
       (when (and path (equal "" (car path)))
         (setq path (cdr path)))
       (while (and path (< (length output) (- max-length 4)))
         (setq output (concat (car path) "/" output))
         (setq path (cdr path)))
       (when path
         (setq output (concat ".../" output)))
       output))


(setq-default mode-line-buffer-identification
  (propertized-buffer-identification "%b "))

(setq-default mode-line-format
      '("%e"
        mode-line-front-space
        ;; mode-line-mule-info -- I'm always on utf-8
        mode-line-client
        mode-line-modified
        ;; mode-line-remote -- no need to indicate this specially
        ;; mode-line-frame-identification -- this is for text-mode emacs only
        " "
        mode-line-directory
        mode-line-buffer-identification
        " "
        mode-line-position
        ;; (vc-mode vc-mode)  -- I use magit, not vc-mode
        ;; (flycheck-mode flycheck-mode-line)
        " "
        ;; mode-line-modes
        mode-line-misc-info
        mode-line-end-spaces))
#+END_SRC


* Magit
#+BEGIN_SRC emacs-lisp
;; Transitional, shouldn't be needed after it can be found in melpa repos
(use-package transient
  :straight (transient :type git :host github :repo "magit/transient" :branch "master"))

(use-package evil-magit
  :straight t)

(use-package magit
  :straight t
  :after transient
  :init
  (setq magit-diff-refine-hunk t
	magit-diff-paint-whitespace t
	magit-diff-highlight-trailing t
	magit-process-popup-time 10
	magit-save-repository-buffers t
	magit-push-current-set-remote-if-missing t)
  :bind (("C-x g" . magit-status))
  :config
  (progn
    (defun ibizaman/magit-lone-branches ()
      (let* ((cmd-output (magit-with-toplevel
                           (shell-command-to-string "git for-each-ref --format='%(refname:short) %(upstream)' refs/heads")))
             (branches (split-string cmd-output "\n"))
             (lone-branches (seq-filter (lambda (elt) (= 1 (length (split-string elt)))) branches)))
        (seq-map (lambda (elt) (car (split-string elt))) lone-branches)))

    (defun ibizaman/magit-get-ref (name)
      (let* ((cmd (concat "git show-ref --hash " name))
             (all-sha1 (magit-with-toplevel (shell-command-to-string cmd))))
        (car (split-string all-sha1))))

    (defun ibizaman/magit-merged-branchp (branch &optional master)
      (let* ((master (or master "origin/master"))
             (master-sha1 (ibizaman/magit-get-ref master))
             (branch-sha1 (ibizaman/magit-get-ref branch)))
        (= 0 (magit-with-toplevel (call-process "git" nil nil nil "merge-base" "--is-ancestor" branch-sha1 master-sha1)))))

    (defun ibizaman/magit-clean-lone-branch (&optional branch-to-clean)
      (interactive
       (list (completing-read "Select lone branch to clean:" (seq-filter 'ibizaman/magit-merged-branchp (ibizaman/magit-lone-branches))))))))


(use-package forge
  :straight (forge :type git :host github :repo "magit/forge" :branch "master")
  :after (magit transient)
  :config
  (push '("ibizaman.github.com" "api.github.com" "github.com" forge-github-repository)
        forge-alist))


(defun ibizaman/magit-commit-create-WIP ()
  "Commit non-interactively a WIP commit."
  (interactive)
  (ibizaman/magit-commit-create-message "WIP"))

(defun ibizaman/magit-commit-create-message (message)
  "Commit non-interactively with a given MESSAGE."
  (interactive)
  (magit-commit-create (list (concat "-m " message))))

(defun ibizaman/magit-reset-head ()
  "Reset non-interactively to HEAD^."
  (interactive)
  (magit-reset-soft "HEAD^"))

(transient-append-suffix 'magit-commit 'magit-commit-create '("W" "Commit WIP" ibizaman/magit-commit-create-WIP))

(transient-append-suffix 'magit-reset 'magit-reset-worktree '("W" "mixed to HEAD^" ibizaman/magit-reset-head))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package git-link
  :straight t
  :config
  (defun git-link-master-branch ()
    (interactive)
    (let ((git-link-default-branch "master"))
      (call-interactively 'git-link)))
  (defun git-link-at-commit ()
    (interactive)
    (let ((git-link-use-commit t))
      (call-interactively 'git-link)))
  (defun git-link-master-branch-at-commit ()
    (interactive)
    (let ((git-link-default-branch "master")
	  (git-link-use-commit t))
      (call-interactively 'git-link))))

(use-package git-gutter-fringe+
  :straight t
  :after git-gutter+
  :config
  (setq git-gutter-fr+-side 'right-fringe)
  (global-git-gutter+-mode 1)
  (git-gutter-fr+-minimal)
  (git-gutter+-toggle-fringe))
#+END_SRC

* Linting
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :straight t
  :config
  (setq flycheck-command-wrapper-function
        (lambda (command)
          (if (null (string-match "pylint" (car command)))
              command
	    (let* ((new-prefix (replace-regexp-in-string "pylint$" "python" (car command)))
		   (new-rest (append '("-m" "pylint") (cdr command)))
		   (new-command (append (list new-prefix) new-rest)))
	      new-command))))
  (global-flycheck-mode))

(use-package flycheck-popup-tip
  :straight t
  :after flycheck
  :config
  (flycheck-popup-tip-mode))
#+END_SRC

* Spelling
TODO: slow in org-mode
#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :config
  (progn
    (add-hook 'text-mode-hook #'turn-on-flyspell)
    (add-hook 'org-mode-hook #'turn-on-flyspell)
    (add-hook 'prog-mode-hook 'flyspell-prog-mode))
  (setq flyspell-issue-message-flag nil)  ; speedup checking entire buffer
  )

(use-package flyspell-popup
  :straight t
  :after flyspell)

(use-package ispell
  :config
  (when (executable-find "hunspell")
    (setenv "DICPATH" (expand-file-name "~/Library/Spelling/"))
    (setq ispell-program-name "hunspell"
          ispell-really-hunspell t
          ispell-dictionary "en_US")
    (ispell-set-spellchecker-params)
    (ispell-hunspell-add-multi-dic "en_US,francais")))

#+END_SRC

* Autocompletion
#+BEGIN_SRC emacs-lisp
(use-package company
  :straight t
  :init
  (add-hook 'after-init-hook 'global-company-mode)
  :config
  (evil-define-key 'insert 'global (kbd "<tab>") 'company-complete))



(use-package company-emoji
  :straight t
  :after company
  :config
  (add-to-list 'company-backends 'company-emoji))

(use-package company-lsp
  :straight t
  :after company
  :config
  (add-to-list 'company-backends 'company-lsp))

(use-package company-quickhelp
  :straight t
  :after company
  :config
  (company-quickhelp-mode))
#+END_SRC

* EWW

Add org links to eww pages:
#+BEGIN_SRC emacs-lisp
(use-package org-eww)
#+END_SRC

* Languages
** Common
#+BEGIN_SRC emacs-lisp
(use-package poporg
  :straight t
  :bind (("C-c '" . poporg-dwim)
         :map poporg-mode-map
         ("C-c '" . poporg-edit-exit)))
#+END_SRC

** Python
#+BEGIN_SRC emacs-lisp :tangle no
(use-package pyenv-mode
  :straight t
  :config
  (pyenv-mode)
  (defun ibizaman/pyenv-virtualenv-create (&optional env name)
    (interactive (list (completing-read "What python version to use: " (pyenv-mode-versions))
                       (read-string "Name of the new virtualenv: "))))
  (ibizaman/define-keymap
   'pyenv-mode-map
   `((,(kbd "C-c p p") . pyenv-mode-set)
     (,(kbd "C-c p u") . pyenv-mode-unset)
     (,(kbd "C-c p c") . ibizaman/pyenv-virtualenv-create))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package pytest
  :straight t
  :bind (("C-c t t" . pytest-one)
	 ("C-c t m" . pytest-module)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package jedi
  :straight t
  :config
  (add-hook 'python-mode-hook 'jedi:setup)
  (setq jedi:complete-on-dot t))

(use-package company-jedi
  :straight t
  :after jedi company
  :init
  (defun my/python-mode-hook-company-jedi ()
    (add-to-list 'company-backends 'company-jedi))
  (add-hook 'python-mode-hook 'my/python-mode-hook-company-jedi))

#+END_SRC

** Json
#+BEGIN_SRC emacs-lisp
(use-package json-mode
  :straight t)
#+END_SRC

** Yaml
#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
  :straight t
  :config
  (defun ibizaman/yaml-mode-hook ()
    (setq-local evil-shift-width yaml-indent-offset))
  (add-hook 'yaml-mode-hook 'ibizaman/yaml-mode-hook))
#+END_SRC

** Html
#+BEGIN_SRC emacs-lisp
(use-package htmlize
  :straight t)
#+END_SRC

** Groovy
#+BEGIN_SRC emacs-lisp
(use-package groovy-mode
  :straight t)
#+END_SRC

** Markdown
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :straight t)
#+END_SRC

** Elisp
#+BEGIN_SRC emacs-lisp
(defun eval-point-region-and-deactivate ()
  "Evaluate region or expanded region and deactivates region when done."
  (interactive)
  (use-region-or-expand-region)
  (condition-case-unless-debug err
      (call-interactively 'eval-region)
    (error (deactivate-mark)
           (signal (car err) (cdr err))))
  (deactivate-mark))


(use-package elisp-mode
  :bind (("C-c C-c" . eval-point-region-and-deactivate)))
#+END_SRC

** Elm
#+BEGIN_SRC emacs-lisp
(defun ibizaman/elm-mode-hook ()
  (set (make-local-variable 'eldoc-documentation-function)
       'elm-oracle-type-at-point))

(use-package elm-mode
  :straight t
  :config
  (add-hook 'elm-mode-hook #'ibizaman/elm-mode-hook)
  (add-hook 'elm-mode-hook #'elm-format-on-save-mode))

(use-package flycheck-elm
  :straight t
  :after flycheck
  :init
  (add-hook 'flycheck-mode-hook #'flycheck-elm-setup))
#+END_SRC

** Haskell
#+BEGIN_SRC emacs-lisp
(use-package haskell-mode
  :straight t)

(use-package intero
  :straight t
  :config
  (intero-global-mode 1))
#+END_SRC

** Systemd
#+BEGIN_SRC emacs-lisp
(use-package systemd
  :straight t)
#+END_SRC

** Package Manager
#+BEGIN_SRC emacs-lisp
(use-package system-packages
  :straight t)
#+END_SRC

** Graphviz
#+BEGIN_SRC emacs-lisp
(use-package graphviz-dot-mode
  :straight t)
#+END_SRC

** Docker
#+BEGIN_SRC emacs-lisp
(use-package docker
  :straight t)

(use-package dockerfile-mode
  :straight t)
#+END_SRC

** Lua
#+BEGIN_SRC emacs-lisp
(use-package lua-mode
  :straight t)
#+END_SRC

** Bash
#+BEGIN_SRC emacs-lisp :tangle no :results silent
(system-packages-install "shellcheck")
#+END_SRC

** Docker
#+BEGIN_SRC emacs-lisp :tangle no :results silent
(system-packages-install "hadolint")
#+END_SRC

** Applescript
#+BEGIN_SRC emacs-lisp
(use-package applescript-mode
  :straight t)
#+END_SRC

** Go
*** Install instructions
:PROPERTIES:
:HEADER-ARGS: :tangle no
:END:

Needs:
#+BEGIN_SRC bash :results output
go get -u github.com/nsf/gocode
#+END_SRC

#+BEGIN_SRC bash :results output
go get -u golang.org/x/tools/cmd/guru
#+END_SRC

#+BEGIN_SRC bash :results output
go get -u github.com/rogpeppe/godef
#+END_SRC

#+BEGIN_SRC bash :results output
go get -u github.com/go-delve/delve/cmd/dlv
#+END_SRC

#+BEGIN_SRC bash :results output
go get -u github.com/golangci/golangci-lint/cmd/golangci-lint
#+END_SRC


*** Config
#+BEGIN_SRC emacs-lisp
(use-package go-mode
  :straight t
  :config
  (require 'go-guru)
  (add-hook 'go-mode-hook (lambda ()
                            (add-hook 'before-save-hook 'gofmt-before-save nil t))) ; local hook
  (subword-mode 1)

  ; Fix regexp for finding errors
  (setq compilation-error-regexp-alist-alist
        (assq-delete-all 'go-test compilation-error-regexp-alist-alist))
  (add-to-list 'compilation-error-regexp-alist-alist
               '(go-test "^\\(?:[ 	]\\)+\\([^():	\n]+?\\):\\([0-9]+\\):" 1 2)
               t)
  (pushnew 'go-test compilation-error-regexp-alist)

  ; GOROOT needs to be set explicitly for go-guru.
  (setenv "GOROOT" (string-trim (shell-command-to-string "go env GOROOT")))
  (setenv "GOPATH" (expand-file-name "~/go"))

  :bind (:map go-mode-map
         ("C-h C-g" . godoc-at-point)))

(use-package go-eldoc
  :straight t
  :after go-mode
  :config
  (add-hook 'go-mode-hook 'go-eldoc-setup))


(defun ibizaman/go-install-dwim()
  "Install current buffer."
  (interactive)
  (shell-command "go install ./..."))


(defun ibizaman/go-generate-dwim()
  "Generate go code from current buffer's directory."
  (interactive)
  (shell-command "go generate -v ./..."))


(defun ibizaman/go-doc-serve()
  "Install current buffer."
  (interactive)
  (start-process-shell-command "*godoc serve*" "*godoc serve*" "godoc -http=:6060")
  (browse-url "http://localhost:6060"))
(use-package go-guru
  :straight t)

(use-package flycheck-golangci-lint
  :straight t
  :hook
  (go-mode . flycheck-golangci-lint-setup)
  :config
  (flycheck-add-next-checker 'golangci-lint 'go-gofmt)
  (flycheck-add-next-checker 'golangci-lint 'go-build)
  (flycheck-add-next-checker 'golangci-lint 'go-test))

(use-package company-go
  :straight t
  :after company go-mode
  :config
  (add-hook 'go-mode-hook (lambda ()
                            (set (make-local-variable 'company-backends) (push 'company-go company-backends))
                            (company-mode))))

(use-package gotest
  :straight t
  :after company go-mode)

(use-package ob-go
  :straight t)

(use-package go-dlv
  :straight t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(eval-after-load 'hydra
  '(progn
     (defgroup go-test-args nil
       "Go test args specific customization."
       :group 'go-test)


     (defcustom go-test-args-base-tags '("unit")
       "Available tags that can be toggled."
       :group 'go-test-args
       :type '(repeat string))

     (defvar go-test-args-tags nil
       "Go test arg --tags=")

     (defun go-test-args-tags-toggle ()
       "Toggle tags argument."
       (go-test-args--toggle-list 'go-test-args-tags 'go-test-args-base-tags))

     (defun go-test-args-tags-arg ()
       "Get tags argument."
       (if (null go-test-args-tags) ""
         (format "--tags=\"%s\"" (mapconcat 'identity (symbol-value 'go-test-args-tags) " "))))


     (defcustom go-test-args-base-cpu '("1" "2" "3" "4" "5" "6" "7" "8")
       "Available tags that can be toggled."
       :group 'go-test-args
       :type '(repeat string))

     (defvar go-test-args-cpu nil
       "Go test arg --cpu=")

     (defun go-test-args-cpu-toggle ()
       "Toggle cpu argument."
       (go-test-args--toggle-list 'go-test-args-cpu 'go-test-args-base-cpu))

     (defun go-test-args-cpu-arg ()
       "Get cpu argument."
       (if (null go-test-args-cpu) ""
         (format "--cpu=%s" (mapconcat 'identity (symbol-value 'go-test-args-cpu) ","))))


     (defvar go-test-args-verbose nil
       "Go test arg -v")

     (defun go-test-args-verbose-toggle ()
       "Toggle verbose argument."
       (go-test-args--toggle-bool 'go-test-args-verbose))

     (defun go-test-args-verbose-arg ()
       "Get verbose argument."
       (if go-test-args-verbose "-v" ""))


     (defvar go-test-args-race nil
       "Go test arg --race")

     (defun go-test-args-race-toggle ()
       "Toggle race argument."
       (go-test-args--toggle-bool 'go-test-args-race))

     (defun go-test-args-race-arg ()
       "Get race argument."
       (if go-test-args-race "--race" ""))


     (defvar go-test-args-count nil
       "Go test arg --count")

     (defun go-test-args-count-toggle ()
       "Toggle count argument."
       (go-test-args--toggle-number 'go-test-args-count))

     (defun go-test-args-count-arg ()
       "Get count argument."
       (if (null go-test-args-count) ""
         (format "--count=\"%s\"" go-test-args-count)))


     (defvar go-test-args-parallel nil
       "Go test arg --parallel")

     (defun go-test-args-parallel-toggle ()
       "Toggle parallel argument."
       (go-test-args--toggle-number 'go-test-args-parallel))

     (defun go-test-args-parallel-arg ()
       "Get parallel argument."
       (if (null go-test-args-parallel) ""
         (format "--parallel=\"%s\"" go-test-args-parallel)))


     (defvar go-test-args-coverprofile nil
       "Go test arg --coverprofile")

     (defun go-test-args-coverprofile-toggle ()
       "Toggle coverprofile argument."
       (go-test-args--toggle-str 'go-test-args-coverprofile))

     (defun go-test-args-coverprofile-arg ()
       "Get coverprofile argument."
       (if (null go-test-args-coverprofile) ""
         (format "--coverprofile=\"%s\"" go-test-args-coverprofile)))


     (defvar go-test-args-coverpkg nil
       "Go test arg --coverpkg=")

     (defun go-test-args-coverpkg-toggle ()
       "Toggle coverpkg argument."
       (go-test-args--toggle-list 'go-test-args-coverpkg ()))

     (defun go-test-args-coverpkg-arg ()
       "Get coverpkg argument."
       (if (null go-test-args-coverpkg) ""
         (format "--coverpkg=\"%s\"" (mapconcat 'identity (symbol-value 'go-test-args-coverpkg) ","))))


     (defun go-test-args--set-global-var ()
       "Set go-test-args from variables toggled in this module."
       (let* ((allvalues `(,(go-test-args-tags-arg)
                           ,(go-test-args-count-arg)
                           ,(go-test-args-parallel-arg)
                           ,(go-test-args-verbose-arg)
                           ,(go-test-args-race-arg)
                           ,(go-test-args-cpu-arg)
                           ,(go-test-args-coverprofile-arg)
                           ,(go-test-args-coverpkg-arg)))
              (nonnil (seq-filter (lambda (elem) (not (or (null elem) (equal elem ""))))
                                  allvalues)))
         (setq go-test-args (mapconcat 'identity nonnil " "))))


     (defun go-test-args--toggle-in-list (list element)
       "Toggles an ELEMENT in a LIST."
       (if (member element (symbol-value list))
           (set list (delete element (symbol-value list)))
         (sort (add-to-list list element) 'string<)))

     (defun go-test-args--toggle-list (var base-var)
       "Toggle an element from BASE-VAR in VAR."
       (let* ((toggle-list (sort (delete-dups (append (symbol-value base-var) (copy-sequence (symbol-value var)))) 'string<))
              (element (completing-read "Pick an element to toggle: " toggle-list)))
         (go-test-args--toggle-in-list var element))
       (go-test-args--set-global-var))

     (defun go-test-args--toggle-bool (var)
       (if (symbol-value var)
           (set var nil)
         (set var t))
       (go-test-args--set-global-var))

     (defun go-test-args--toggle-number (var)
       (let ((number (read-string "Enter a number (leave empty to unset the argument): ")))
         (if (equal number "")
             (set var nil)
           (set var number)))
       (go-test-args--set-global-var))

     (defun go-test-args--toggle-str (var)
       (let ((value (read-string "Enter a value (leave empty to unset the argument): ")))
         (if (equal value "")
             (set var nil)
           (set var value)))
       (go-test-args--set-global-var))

     (defhydra go-test-args-hydra (:hint nil)
       "
_T_ags:            %`go-test-args-tags
_C_ount:           %`go-test-args-count
_P_arallel:        %`go-test-args-parallel
_v_erbose:         %`go-test-args-verbose
_r_ace:            %`go-test-args-race
cp_u_:             %`go-test-args-cpu
c_o_verprofile:    %`go-test-args-coverprofile
coverp_k_g:        %`go-test-args-coverpkg

go-test-args: %s(symbol-value 'go-test-args)

_t_: run current _t_est   _b_: run current _b_enchmark   _O_: show coverage
_f_:      ... in _f_ile   _B_:           ^^... in file
_p_:   ... in _p_ackage   _N_:        ^^... in package
"
       ("T" (go-test-args-tags-toggle))
       ("C" (go-test-args-count-toggle))
       ("P" (go-test-args-parallel-toggle))
       ("v" (go-test-args-verbose-toggle))
       ("r" (go-test-args-race-toggle))
       ("u" (go-test-args-cpu-toggle))
       ("o" (go-test-args-coverprofile-toggle))
       ("k" (go-test-args-coverpkg-toggle))

       ("t" (go-test-current-test) :color blue)
       ("f" (go-test-current-file) :color blue)
       ("p" (go-test-current-project) :color blue)
       ("b" (go-test-current-benchmark) :color blue)
       ("B" (go-test-current-file-benchmarks) :color blue)
       ("N" (go-test-current-project-benchmarks) :color blue)
       ("O" (go-coverage) :color blue))

     (define-key go-mode-map (kbd "C-c t") 'go-test-args-hydra/body)))
#+END_SRC

** Protobuf
#+BEGIN_SRC emacs-lisp
(use-package protobuf-mode
  :straight t
  :config
  (unbind-key "C-c C-l" protobuf-mode-map))
#+END_SRC

** Mongo
#+BEGIN_SRC emacs-lisp
(use-package ob-mongo
  :straight t)
#+END_SRC

** Elasticsearch
#+BEGIN_SRC emacs-lisp
(use-package es-mode
  :straight t)
#+END_SRC

** PICASM
#+BEGIN_SRC emacs-lisp
(use-package picasm
  :straight (picasm :type git :host github :repo "rswarbrick/picasm" :branch "master"))
#+END_SRC
** SQL
#+BEGIN_SRC emacs-lisp
(use-package sql-indent
  :straight t)
#+END_SRC

* Secrets
#+BEGIN_SRC emacs-lisp
(use-package pass
  :straight t)

(use-package auth-source)

(use-package auth-source-pass
  :straight t
  :config
  (auth-source-pass-enable))
#+END_SRC

** Makefile
#+BEGIN_SRC emacs-lisp
(use-package makefile-executor
  :straight t
  :config
  (add-hook 'makefile-mode-hook 'makefile-executor-mode))
#+END_SRC

* Email
** Install instructions
:PROPERTIES:
:HEADER-ARGS: :tangle no
:END:
#+BEGIN_SRC bash
git clone git://github.com/djcb/mu.git
cd mu
brew install gmime
./autogen.sh && ./configure && make
sudo make install
#+END_SRC

** Config
#+BEGIN_SRC emacs-lisp :tangle no
(add-to-list 'load-path "~/.emacs.d/straight/repos/mu4e/mu4e")
(use-package mu4e
  :config
  (require 'mu4e-contrib)

  (progn
    (defcustom ibizaman/mu4e-unread-excluded-lists nil
      "Mailing lists to be excluded from default unread view."
      :group 'mu4e
      :type '(repeat string))

    (defun ibizaman/mu4e-add-message-list-to-excluded-lists (msg)
      (let ((list (mu4e-message-field msg :mailing-list)))
        (add-to-list 'ibizaman/mu4e-unread-excluded-lists list)
        (message "Added %s to excluded list" list)))

    (add-to-list 'mu4e-headers-actions
                 '("Exclude list" . ibizaman/mu4e-add-message-list-to-excluded-lists) t)

    (defun ibizaman/mu4e-generate-unread-filter ()
      (concat "flag:unread "
              "AND NOT flag:trashed "
              "AND NOT maildir:/Gmail/recruiting "
              "AND NOT maildir:\"/Gmail/[Google Mail].Trash\" "
              "AND NOT maildir:\"/Gmail/[Google Mail].Spam\" "
              (mapconcat (lambda (v) (concat " AND NOT list:" v))
                         ibizaman/mu4e-unread-excluded-lists "")))

    (defun ibizaman/mu4e-get-unread-list-filter-query (wanted-list)
      (interactive (list (completing-read "List: " ibizaman/mu4e-unread-excluded-lists)))
      (concat "flag:unread AND NOT flag:trashed AND list:" wanted-list)))

  (setq mail-user-agent        'mu4e-user-agent
        mu4e-maildir           "~/Maildir"
        mu4e-use-fancy-chars   t
        mu4e-attachment-dir    "~/Maildir/Attachments/Gmail"
        mu4e-view-show-images  t
        mu4e-confirm-quit      nil
        mu4e-completing-read-function 'ivy-completing-read
        mu4e-hide-index-messages t
        message-kill-buffer-on-exit   t
        mu4e-html2text-command 'mu4e-shr2text
        shr-color-visible-luminance-min 80  ; for dark themes
        shr-color-visible-distance-min 5
        mu4e-refile-folder "/Gmail/[Google Mail].All Mail")
  (defun ibizaman/mu4e-set-contexts ()
    (setq mu4e-contexts
          `( ,(make-mu4e-context
               :name "Private"
               :enter-func (lambda () (mu4e-message "Entering Private context"))
               :leave-func (lambda () (mu4e-message "Leaving Private context"))
               ;; we match based on the contact-fields of the message
               :match-func (lambda (msg)
                             (when msg
                               (string-match-p "^/Gmail" (mu4e-message-field msg :maildir))))
               :vars `( ( user-mail-address      . "ibizapeanut@gmail.com"  )
                        ( user-full-name         . "Pierre Penninckx" )
                        ( mu4e-drafts-folder     . "/Gmail/[Google Mail].Drafts" )
                        ( mu4e-sent-folder       . "/Gmail/[Google Mail].Sent Mail" )
                        ( mu4e-trash-folder      . "/Gmail/[Google Mail].Trash" )
                        ;; don't save message to Sent Messages, Gmail/IMAP takes care of this
                        ( mu4e-sent-messages-behavior . delete )
                        ( mu4e-maildir-shortcuts .
                                                 ( ("/Gmail/INBOX"                     . ?i)
                                                   ("/Gmail/recruiting"                . ?r)
                                                   ("/Gmail/[Google Mail].Sent Mail"   . ?s)
                                                   ("/Gmail/[Google Mail].Trash"       . ?t)
                                                   ("/Gmail/[Google Mail].All Mail"    . ?a)) )
                        ( mu4e-get-mail-command . "offlineimap" )
                        ( mu4e-bookmarks .
                                         (,(make-mu4e-bookmark
                                            :name  "Unread messages not list"
                                            :query (lambda () (ibizaman/mu4e-generate-unread-filter))
                                            :key ?u)
                                          ,(make-mu4e-bookmark
                                            :name  "Recruiting"
                                            :query "maildir:/Gmail/recruiting"
                                            :key ?r)
                                          ,(make-mu4e-bookmark
                                            :name  "Unread messages all"
                                            :query (concat "flag:unread "
                                                           "AND NOT flag:trashed"
                                                           "AND NOT maildir:\"/Gmail/[Google Mail].Trash\" "
                                                           "AND NOT maildir:\"/Gmail/[Google Mail].Spam\" ")
                                            :key ?i)
                                          ,(make-mu4e-bookmark
                                            :name  "Unread list messages"
                                            :query (lambda () (call-interactively 'ibizaman/mu4e-get-unread-list-filter-query))
                                            :key ?l)
                                          ,(make-mu4e-bookmark
                                            :name "Today's messages"
                                            :query "date:today..now"
                                            :key ?t)
                                          ,(make-mu4e-bookmark
                                            :name "Last 7 days"
                                            :query "date:7d..now AND NOT flag:list AND NOT maildir:/Gmail/recruiting"
                                            :key ?w)
                                          ,(make-mu4e-bookmark
                                            :name "Messages with images"
                                            :query "mime:image/*"
                                            :key ?p)
                                          ,(make-mu4e-bookmark
                                            :name "Drafts"
                                            :query "flag:draft"
                                            :key ?d))))))))
  (ibizaman/mu4e-set-contexts)

  (require 'smtpmail)
  (setq message-send-mail-function 'smtpmail-send-it
        user-mail-address "ibizapeanut@gmail.com"
        starttls-use-gnutls t
        starttls-gnutls-program "gnutls-cli"
        starttls-extra-arguments nil
        smtpmail-default-smtp-server "smtp.gmail.com"
        smtpmail-smtp-server "smtp.gmail.com"
        smtpmail-smtp-service 587
        smtpmail-debug-info t
        smtpmail-smtp-user "ibizapeanut@gmail.com"))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(use-package org-mu4e
  :after org mu4e)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(use-package mu4e-maildirs-extension
  :straight t
  :after mu4e
  :config
  (mu4e-maildirs-extension))
#+END_SRC

* Elfeed
#+BEGIN_SRC emacs-lisp
(use-package elfeed
  :straight t)
#+END_SRC

Add all feeds from [[http://planet.emacsen.org/][Planet Emacsen]]:
#+BEGIN_SRC emacs-lisp
(defcustom ibizaman/elfeed-planet-emacsen "http://planet.emacsen.org/"
  "URL for planet Emacsen."
  :group 'elfeed
  :type 'string)

(require 'url)

(defun ibizaman/elfeed-pe-update ()
  "Update `elfeed-feeds' from Planet Emacsen feeds."
  (interactive)
  (url-retrieve
   ibizaman/elfeed-planet-emacsen
   #'ibizaman/elfeed-pe--update-worker
   nil t 10))

(defun ibizaman/elfeed-pe--update-worker (&optional status cbargs)
  (mapc
   (lambda (feed) (elfeed-add-feed feed))
   (ibizaman/elfeed-pe--parse-feeds-buffer)))

(defun ibizaman/elfeed-pe--parse-feeds-buffer ()
  "Parse current buffer and extract rss feeds."
  (let* ((dom (libxml-parse-html-region (point-min) (point-max)))
         (sidebar (dom-by-id dom "sidebar"))
         (sidebar-inner (dom-by-tag sidebar 'ul))
         (feed-outer-list (nth 6 (dom-children sidebar-inner)))
         (feed-inner-list (dom-by-tag feed-outer-list 'ul))
         (elems (dom-by-tag feed-inner-list 'li))
         (feeds
          (mapcar
           (lambda (li)
             (let* ((links (dom-by-tag li 'a))
                    (feed-link (nth 1 links)))
               (dom-attr feed-link 'href)))
           elems)))
    feeds))
#+END_SRC

* Workspace
#+BEGIN_SRC emacs-lisp
(use-package nameses
  :straight (nameses :type git :host nil :repo "https://gist.github.com/8960595.git")
  :init (require 'desktop))

(defun nameses-create ()
  (interactive)
  (let ((current-prefix-arg '(4)))
    (call-interactively 'nameses-load)))
#+END_SRC

I have NO idea why I need that second use-package, but without it the :config section doesn't get executed
#+BEGIN_SRC emacs-lisp
(use-package eyebrowse
  :straight t
  ; :init (message "EYEBROWSE 1")
  :config
  ; (message "EYEBROWSE 2")
  (add-to-list 'window-persistent-parameters '(window-side . writable))
  (add-to-list 'window-persistent-parameters '(window-slot . writable))
  (setq eyebrowse-new-workspace t)
  (eyebrowse-mode)
  ; (message "EYEBROWSE 3")
  :bind (:map eyebrowse-mode-map
         ("C-c C-w h" . eyebrowse-switch-to-window-config-1)
         ("C-c C-w j" . eyebrowse-switch-to-window-config-2)
         ("C-c C-w k" . eyebrowse-switch-to-window-config-3)
         ("C-c C-w l" . eyebrowse-switch-to-window-config-4)
         ("C-c C-w n" . eyebrowse-switch-to-window-config-5)
         ("C-c C-w m" . eyebrowse-switch-to-window-config-6)
         ("C-c C-w ," . eyebrowse-switch-to-window-config-7)
         ("C-c C-w ." . eyebrowse-switch-to-window-config-8)
         ("C-c C-w n" . eyebrowse-next-window-config)
         ("C-c C-w p" . eyebrowse-prev-window-config)
         ("C-c C-w C-n" . eyebrowse-next-window-config)
         ("C-c C-w C-p" . eyebrowse-prev-window-config)))

(use-package eyebrowse)
#+END_SRC

* Slack
#+BEGIN_SRC emacs-lisp
(use-package slack
  :straight t
  :commands (slack-start)
  :init
  (setq slack-buffer-emojify t
        slack-prefer-current-team t
        slack-completing-read-function #'ivy-completing-read
        slack-buffer-function #'switch-to-buffer
        slack-display-team-name nil
        slack-request-timeout 100)
  :config
  (slack-register-team
   :name "emacs-slack"
   :default t
   :client-id (auth-source-pass-get 'secret "slack.com/pierre@openmail.co/client-id")
   :client-secret (auth-source-pass-get 'secret "slack.com/pierre@openmail.co/client-secret")
   :token (auth-source-pass-get 'secret "slack.com/pierre@openmail.co/token")
   :full-and-display-names t)
  :bind (("C-j" . #'slack-buffer-goto-next-message)
         ("C-k" . #'slack-buffer-goto-prev-message)))
#+END_SRC

* Jira
#+BEGIN_SRC emacs-lisp
(use-package org-jira
  :straight (org-jira :type git :host nil :repo "https://github.com/ahungry/org-jira.git"))
#+END_SRC

* Dired
From [[https://oremacs.com/2017/03/18/dired-ediff/][abo-abo]]:
#+BEGIN_SRC emacs-lisp
(require 'cl)

(when (string= system-type "darwin")
  (setq dired-use-ls-dired nil))

(defun ibizaman/frame-filenames ()
  (mapcar 'buffer-file-name
          (mapcar 'window-buffer
                  (window-list))))

(defun ibizaman/ediff-files (&optional files quit-hook)
  (interactive)
  (lexical-let ((files (or files (dired-get-marked-files) (ibizaman/frame-filenames)))
                (quit-hook quit-hook)
                (wnd (current-window-configuration)))
    (if (<= (length files) 2)
        (let ((file1 (car files))
              (file2 (if (cdr files)
                         (cadr files)
                       (read-file-name
                        "file: "
                        (dired-dwim-target-directory)))))
          (if (file-newer-than-file-p file1 file2)
              (ediff-files file2 file1)
            (ediff-files file1 file2))
          (add-hook 'ediff-after-quit-hook-internal
                    (lambda ()
                      (setq ediff-after-quit-hook-internal nil)
                      (when quit-hook (funcall quit-hook))
                      (set-window-configuration wnd))))
      (error "no more than 2 files should be marked"))))

(define-key dired-mode-map "e" 'ora-ediff-files)
#+END_SRC

[[customize-group:dired][Customize group for dired]]
[[customize-group:wdired][Customize group for wdired]]

* Hydra

#+BEGIN_SRC emacs-lisp
(use-package hydra
  :straight t
  :after ibuffer)
#+END_SRC

** occur
#+BEGIN_SRC emacs-lisp
(progn
  ;; Keeps focus on *Occur* window, even when when target is visited via RETURN key.
  ;; See hydra-occur-dwim for more options.
  (defadvice occur-mode-goto-occurrence (after occur-mode-goto-occurrence-advice activate)
    (other-window 1)
    (hydra-occur-dwim/body))

  ;; Used in conjunction with occur-mode-goto-occurrence-advice this helps keep
  ;; focus on the *Occur* window and hides upon request in case needed later.
  (defhydra hydra-occur-dwim ()
    "Occur mode"
    ("o" occur-dwim "Start occur-dwim" :color red)
    ("j" occur-next "Next" :color red)
    ("k" occur-prev "Prev":color red)
    ("h" delete-window "Hide" :color blue)
    ("r" (reattach-occur) "Re-attach" :color red))

  (global-set-key (kbd "C-x o") 'hydra-occur-dwim/body))
#+END_SRC

** dired
#+BEGIN_SRC emacs-lisp :tangle no
(require 'dired)

(defhydra hydra-dired (:hint nil :color pink)
  "
_+_ mkdir          _v_iew           _m_ark             _(_ details        _i_nsert-subdir    wdired
_C_opy             _O_ view other   _U_nmark all       _)_ omit-mode      _$_ hide-subdir    C-x C-q : edit
_D_elete           _o_pen other     _u_nmark           _l_ redisplay      _w_ kill-subdir    C-c C-c : commit
_R_ename           _M_ chmod        _t_oggle           _g_ revert buf     _e_ ediff          C-c ESC : abort
_Y_ rel symlink    _G_ chgrp        _E_xtension mark   _s_ort             _=_ pdiff
_S_ymlink          ^ ^              _F_ind marked      _._ toggle hydra   \\ flyspell
_r_sync            ^ ^              ^ ^                ^ ^                _?_ summary
_z_ compress-file  _A_ find regexp
_Z_ compress       _Q_ repl regexp

T - tag prefix
"
  ("\\" dired-do-ispell)
  ("(" dired-hide-details-mode)
  (")" dired-omit-mode)
  ("+" dired-create-directory)
  ("=" diredp-ediff)         ;; smart diff
  ("?" dired-summary)
  ("$" diredp-hide-subdir-nomove)
  ("A" dired-do-find-regexp)
  ("C" dired-do-copy)        ;; Copy all marked files
  ("D" dired-do-delete)
  ("E" dired-mark-extension)
  ("e" dired-ediff-files)
  ("F" dired-do-find-marked-files)
  ("G" dired-do-chgrp)
  ("g" revert-buffer)        ;; read all directories again (refresh)
  ("i" dired-maybe-insert-subdir)
  ("l" dired-do-redisplay)   ;; relist the marked or singel directory
  ("M" dired-do-chmod)
  ("m" dired-mark)
  ("O" dired-display-file)
  ("o" dired-find-file-other-window)
  ("Q" dired-do-find-regexp-and-replace)
  ("R" dired-do-rename)
  ("r" dired-do-rsynch)
  ("S" dired-do-symlink)
  ("s" dired-sort-toggle-or-edit)
  ("t" dired-toggle-marks)
  ("U" dired-unmark-all-marks)
  ("u" dired-unmark)
  ("v" dired-view-file)      ;; q to exit, s to search, = gets line #
  ("w" dired-kill-subdir)
  ("Y" dired-do-relsymlink)
  ("z" diredp-compress-this-file)
  ("Z" dired-do-compress)
  ("q" nil)
  ("." nil :color blue))

(define-key dired-mode-map (kbd ".") #'hydra-dired/body)
#+END_SRC

** flycheck
#+BEGIN_SRC emacs-lisp :tangle no
(defhydra hydra-flycheck
  (:pre (progn (setq hydra-lv t) (flycheck-list-errors))
        :post (progn (setq hydra-lv nil) (quit-windows-on "*Flycheck errors*"))
        :hint nil)
  "Errors"
  ("f"  flycheck-error-list-set-filter                            "Filter")
  ("j"  flycheck-next-error                                       "Next")
  ("k"  flycheck-previous-error                                   "Previous")
  ("gg" flycheck-first-error                                      "First")
  ("G"  (progn (goto-char (point-max)) (flycheck-previous-error)) "Last")
  ("q"  nil))

(global-set-key (kbd "C-c f") 'hydra-flycheck/body)
#+END_SRC

** ibuffer
#+BEGIN_SRC emacs-lisp :tangle no
(defhydra hydra-ibuffer-main (:color pink :hint nil)
  "
^Mark^         ^Actions^         ^View^          ^Select^              ^Navigation^
_m_: mark      _D_: delete       _g_: refresh    _q_: quit             _k_:   ↑    _h_
_u_: unmark    _s_: save marked  _S_: sort       _TAB_: toggle         _RET_: visit
_*_: specific  _a_: all actions  _/_: filter     _o_: other window     _j_:   ↓    _l_
_t_: toggle    _._: toggle hydra _H_: help       C-o other win no-select
"
  ("m" ibuffer-mark-forward)
  ("u" ibuffer-unmark-forward)
  ("*" hydra-ibuffer-mark/body :color blue)
  ("t" ibuffer-toggle-marks)

  ("D" ibuffer-do-delete)
  ("s" ibuffer-do-save)
  ("a" hydra-ibuffer-action/body :color blue)

  ("g" ibuffer-update)
  ("S" hydra-ibuffer-sort/body :color blue)
  ("/" hydra-ibuffer-filter/body :color blue)
  ("H" describe-mode :color blue)

  ("h" ibuffer-backward-filter-group)
  ("k" ibuffer-backward-line)
  ("l" ibuffer-forward-filter-group)
  ("j" ibuffer-forward-line)
  ("RET" ibuffer-visit-buffer :color blue)

  ("TAB" ibuffer-toggle-filter-group)

  ("o" ibuffer-visit-buffer-other-window :color blue)
  ("q" quit-window :color blue)
  ("." nil :color blue))

(defhydra hydra-ibuffer-mark (:color teal :columns 5
                                     :after-exit (hydra-ibuffer-main/body))
  "Mark"
  ("*" ibuffer-unmark-all "unmark all")
  ("M" ibuffer-mark-by-mode "mode")
  ("m" ibuffer-mark-modified-buffers "modified")
  ("u" ibuffer-mark-unsaved-buffers "unsaved")
  ("s" ibuffer-mark-special-buffers "special")
  ("r" ibuffer-mark-read-only-buffers "read-only")
  ("/" ibuffer-mark-dired-buffers "dired")
  ("e" ibuffer-mark-dissociated-buffers "dissociated")
  ("h" ibuffer-mark-help-buffers "help")
  ("z" ibuffer-mark-compressed-file-buffers "compressed")
  ("b" hydra-ibuffer-main/body "back" :color blue))

(defhydra hydra-ibuffer-action (:color teal :columns 4
                                       :after-exit
                                       (if (eq major-mode 'ibuffer-mode)
                                           (hydra-ibuffer-main/body)))
  "Action"
  ("A" ibuffer-do-view "view")
  ("E" ibuffer-do-eval "eval")
  ("F" ibuffer-do-shell-command-file "shell-command-file")
  ("I" ibuffer-do-query-replace-regexp "query-replace-regexp")
  ("H" ibuffer-do-view-other-frame "view-other-frame")
  ("N" ibuffer-do-shell-command-pipe-replace "shell-cmd-pipe-replace")
  ("M" ibuffer-do-toggle-modified "toggle-modified")
  ("O" ibuffer-do-occur "occur")
  ("P" ibuffer-do-print "print")
  ("Q" ibuffer-do-query-replace "query-replace")
  ("R" ibuffer-do-rename-uniquely "rename-uniquely")
  ("T" ibuffer-do-toggle-read-only "toggle-read-only")
  ("U" ibuffer-do-replace-regexp "replace-regexp")
  ("V" ibuffer-do-revert "revert")
  ("W" ibuffer-do-view-and-eval "view-and-eval")
  ("X" ibuffer-do-shell-command-pipe "shell-command-pipe")
  ("b" nil "back"))

(defhydra hydra-ibuffer-sort (:color amaranth :columns 3)
  "Sort"
  ("i" ibuffer-invert-sorting "invert")
  ("a" ibuffer-do-sort-by-alphabetic "alphabetic")
  ("v" ibuffer-do-sort-by-recency "recently used")
  ("s" ibuffer-do-sort-by-size "size")
  ("f" ibuffer-do-sort-by-filename/process "filename")
  ("m" ibuffer-do-sort-by-major-mode "mode")
  ("b" hydra-ibuffer-main/body "back" :color blue))

(defhydra hydra-ibuffer-filter (:color amaranth :columns 4)
  "Filter"
  ("m" ibuffer-filter-by-used-mode "mode")
  ("M" ibuffer-filter-by-derived-mode "derived mode")
  ("n" ibuffer-filter-by-name "name")
  ("c" ibuffer-filter-by-content "content")
  ("e" ibuffer-filter-by-predicate "predicate")
  ("f" ibuffer-filter-by-filename "filename")
  (">" ibuffer-filter-by-size-gt "size")
  ("<" ibuffer-filter-by-size-lt "size")
  ("/" ibuffer-filter-disable "disable")
  ("b" hydra-ibuffer-main/body "back" :color blue))

(define-key ibuffer-mode-map (kbd "?") 'hydra-ibuffer-main/body)
#+END_SRC

** info
#+BEGIN_SRC emacs-lisp :tangle no
(defhydra hydra-info (:color pink
                             :hint nil)
  "
Info-mode:
_I_ndex(virtual)    _T_OC                            ^ ^^ ^  ^ ^ ^^     _k_/_u_p   ( )
_i_ndex             _t_op node        Node           _[__h_ + _l__]_      _j_/_m_enu ( ) (C-u for new window)
_c_opy node name    _a_propos         Top/Final Node _<__t_   ^ ^_>_      _g_oto node^^    (C-u for new window)
_C_lone buffer      _f_ollow          Level nxt/prev _p_^ ^   ^ ^_n_
_d_irectory         _b_mkp-jump       History        _H_^ ^   ^ ^_L_      _K_ History^^

_s_earch regex (_S_ case sens) ^^^^   _1_ .. _9_ Pick first .. ninth item in the node's menu.
"
  ("j"   Info-menu)              ;; m
  ("k"   Info-up)                ;; ^
  ("m"   Info-menu)
  ("u"   Info-up)

  ("l"   Info-forward-node)
  ("h"   Info-backward-node)
  ("]"   Info-forward-node)
  ("["   Info-backward-node)

  ("t"   Info-top-node)
  ("<"   Info-top-node)
  (">"   Info-final-node)

  ("n"   Info-next)
  ("p"   Info-prev)

  ("K"   Info-history)
  ("H"   Info-history-back)
  ("L"   Info-history-forward)

  ("s"   Info-search)
  ("S"   Info-search-case-sensitively)

  ("g"   Info-goto-node)

  ("f"   Info-follow-reference)
  ("b"   bmkp-info-jump)
  ("i"   Info-index)
  (","   Info-index-next)
  ("I"   Info-virtual-index)

  ("T"   Info-toc)
  ("t"   Info-top-node)
  ("d"   Info-directory)
  ("c"   Info-copy-current-node-name)
  ("C"   clone-buffer)
  ("a"   info-apropos)

  ("1"   Info-nth-menu-item)
  ("2"   Info-nth-menu-item)
  ("3"   Info-nth-menu-item)
  ("4"   Info-nth-menu-item)
  ("5"   Info-nth-menu-item)
  ("6"   Info-nth-menu-item)
  ("7"   Info-nth-menu-item)
  ("8"   Info-nth-menu-item)
  ("9"   Info-nth-menu-item)

  ("?"   Info-summary "Info summary")
  ("y"   Info-help "Info help")
  ("q"   Info-exit "Info exit" :color blue)
  ("C-g" nil "cancel" :color blue))

(define-key Info-mode-map (kbd "?") #'hydra-info/body)
#+END_SRC

** nameses
#+BEGIN_SRC emacs-lisp
(defun hydra-nameses-format (value)
  (truncate-string-to-width (format "%s" value) 15 nil ? t))

(defhydra hydra-nameses (:exit t :hint nil)
  "
^Current^: %s(hydra-nameses-format (nameses-current-name))       ^_s_ave
      _p_: load %s(hydra-nameses-format nameses-prev-session)  ^^^_n_ew
      _d_: load                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^_k_ remove
      _r_eset                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^_q_uit
"
  ("s" nameses-save)
  ("p" nameses-prev)
  ("k" nameses-remove :exit nil)
  ("r" nameses-reset)
  ("d" nameses-load)
  ("n" nameses-create)
  ("q" nil))

(global-set-key (kbd "C-c d") 'hydra-nameses/body)
#+END_SRC

** org-jira
#+BEGIN_SRC emacs-lisp :tangle no
(progn
  (defhydra hydra-org-jira-project (:exit t)
    "Org-jira project"
    ("g" org-jira-get-projects "refresh"))

  (defhydra hydra-org-jira-board (:exit t)
    "Org-jira board"
    ("g" org-jira-get-boards "refresh"))

  (defhydra hydra-org-jira-issue (:exit t)
    "Org-jira board"
    ("g" org-jira-get-issues "get all")
    ("h" org-jira-get-issues-headonly "get all heads")
    ("v" org-jira-get-issues-by-board "get by board")
    ("f" org-jira-get-issues-by-fixversion "get by fixversion")
    ("r" org-jira-refresh-issue "refresh")
    ("R" org-jira-refresh-issues-in-buffer "refresh all")
    ("b" org-jira-browse-issue "browse")
    ("a" org-jira-assign-issue "assign")
    ("k" org-jira-copy-current-issue-key "copy key")
    ("w" org-jira-progress-issue "progress")
    ("n" org-jira-progress-issue-next "progress next")
    ("u" org-jira-update-issue "update")
    ("c" org-jira-create-issue "create"))

  (defhydra hydra-org-jira-comment (:exit t)
    "Org-jira comment"
    ("c" org-jira-add-comment "add")
    ("u" org-jira-update-comment "update"))

  (defhydra hydra-org-jira-subtask (:exit t)
    "Org-jira subtask"
    ("c" org-jira-create-subtask "create")
    ("g" org-jira-get-subtasks "refresh"))

  (defhydra hydra-org-jira-todo (:exit t)
    "Org-jira todo"
    ("j" org-jira-todo-to-jira "update from todo"))

  (defhydra hydra-org-jira-worklog (:exit t)
    "Org-jira worklog"
    ("u" org-jira-update-worklogs-from-org-clocks "update from org clocks"))


  (defhydra hydra-org-jira (org-jira-entry-mode-map "C-c j")
    "Org-jira"
    ("p" hydra-org-jira-project/body "project" :color blue)
    ("b" hydra-org-jira-board/body "board" :color blue)
    ("i" hydra-org-jira-issue/body "issue" :color blue)
    ("c" hydra-org-jira-comment/body "comment" :color blue)
    ("s" hydra-org-jira-subtask/body "subtask" :color blue)
    ("t" hydra-org-jira-todo/body "todo" :color blue)
    ("w" hydra-org-jira-worklog/body "worklog" :color blue))

  (define-key org-mode-map (kbd "C-c j") 'hydra-org-jira/body))
#+END_SRC

** debug
#+BEGIN_SRC emacs-lisp :tangle no
(progn
  (require 'debug)
  (defhydra hydra-elisp (:exit t :hint nil)
    "
^Debug^
^-----^
on _e_ntry
"
    ("e" debug-on-entry))

  (define-key emacs-lisp-mode-map (kbd "C-c e") 'hydra-elisp/body)

  (defhydra hydra-elisp-debug (:post (quit-windows-on "*Backtrace*")
:hint nil)
    "
_c_ontinue  j_u_mp    _e_val
_s_tep      _l_ocals  _f_rame        _t_oggle-debug-on-error
_r_eturn    r_e_cord  _c_lear frame  _q_uit
"
    ("c" debugger-continue)
    ("s" debugger-step-through)
    ("r" debugger-return-value)

    ("u" debugger-jump)
    ("l" debugger-toggle-locals)
    ("e" debugger-record-expression)

    ("e" debugger-eval-expression)
    ("f" debugger-frame)
    ("c" debugger-frame-clear)

    ("t" toggle-debug-on-error)
    ("q" nil)
    )

  (define-key debugger-mode-map (kbd "?") 'hydra-elisp-debug/body)
  (add-hook 'debugger-mode-hook #'hydra-elisp-debug/body))
#+END_SRC

* Polymode
#+BEGIN_SRC emacs-lisp
(use-package polymode
  :straight t)
#+END_SRC

* Work
** OpenMail
#+BEGIN_SRC emacs-lisp :tangle no
(progn
  (setq openmail-project-root (expand-file-name "~/Projects/OpenMail/OpenMail/"))
  (add-to-list 'load-path (concat openmail-project-root "tools/emacs/"))

  (require 'openmail nil t)

  (require 'etl-mode nil t)

  (when (require 'etljenkins-mode nil t)
    (setq etljenkins-mode-groovy-root (concat openmail-project-root "etl/jenkins/")))

  (when (require 'sanitycheck-mode nil t)
    (setq sanitycheck-mode-compiler (concat openmail-project-root "etl/sanity_check_script.py")))
  (require 'ob-sanitycheck nil t)

  (when (require 'copydata-mode nil t)
    (setq copydata-mode-compiler (concat openmail-project-root "etl/copy_data.py")))
  (require 'ob-copydata nil t)

  (require 'ob-sqlplus nil t)

  (require 'pm-yaml nil t))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(setenv "PGCONNECT_TIMEOUT" "5")
#+END_SRC


* Yequake
#+BEGIN_SRC emacs-lisp
(use-package yequake
  :straight (yequake :type git :host nil :repo "https://github.com/alphapapa/yequake.git")
  :config
  (setq yequake-frames
        '(("Mail" .
           ((width . 0.75)
            (height . 0.5)
            (alpha . 0.95)
            (buffer-fns . (mu4e))
            (frame-parameters . ((undecorated . t))))))))
#+END_SRC

* Launcher
:PROPERTIES:
:ID:       A4948FD0-6617-4059-A128-E0C48B1B0E24
:END:
#+BEGIN_SRC emacs-lisp
(defun ibizaman/pass-frame (&optional _switch)
  "Complete pass names in a dedicated frame."
  (interactive)

  (ibizaman/ivy-frame
   "Choose a password:"
   (password-store-list)
   (lambda (entry)
     (password-store--run "show" "--clip" entry))))

(defun ibizaman/ivy-frame (prompt elems action)
  "Show a frame to auto-complete ELEMS using PROMPT.

Then run ACTION with given selected element as argument."
  (with-current-buffer (get-buffer-create "*modal*")
    (let ((frame (make-frame '((auto-raise . t)
                               (background-color . "DeepSkyBlue3")
                               (cursor-color . "MediumPurple1")
                               (font . "Menlo 15")
                               (foreground-color . "#eeeeec")
                               (height . 20)
                               (internal-border-width . 20)
                               (left . 0.33)
                               (left-fringe . 0)
                               (line-spacing . 3)
                               (menu-bar-lines . 0)
                               (minibuffer . only)
                               (right-fringe . 0)
                               (tool-bar-lines . 0)
                               (top . 48)
                               (undecorated . t)
                               (unsplittable . t)
                               (vertical-scroll-bars . nil)
                               (width . 110)))))
      (set-face-attribute 'ivy-minibuffer-match-face-1 frame
                          :background nil
                          :foreground nil)
      (set-face-attribute 'ivy-minibuffer-match-face-2 frame
                          :background nil
                          :foreground "orange1")
      (set-face-attribute 'ivy-minibuffer-match-face-3 frame
                          :background nil
                          :foreground "orange1")
      (set-face-attribute 'ivy-minibuffer-match-face-4 frame
                          :background nil
                          :foreground "orange1")
      (set-face-attribute 'ivy-current-match frame
                          :background "#ffc911"
                          :foreground "red")
      (set-face-attribute 'minibuffer-prompt frame
                          :foreground "grey")
      (let ((ivy-height 20)
            (ivy-count-format ""))
        (ivy-read prompt elems
                  :action action
                  :unwind (lambda ()
                            (shell-command "/Applications/Hammerspoon.app/Contents/Resources/extensions/hs/ipc/bin/hs -c 'backFromEmacs()'")
                            (delete-frame)
                            (other-window 1)))))))
#+END_SRC

* Syncthing
** Handle sync conflicts
#+BEGIN_SRC emacs-lisp
(defun ibizaman/syncthing-resolve-conflicts (directory)
  "Resolve all conflicts under given DIRECTORY."
  (interactive "D")
  (let ((all (ibizaman/syncthing--get-sync-conflicts directory))
        (chosen (ibizaman/syncthing--pick-a-conflict all)))
    (ibizaman/syncthing-resolve-conflict chosen)))


(defun ibizaman/syncthing-show-conflicts-dired (directory)
  "Open dired buffer at DIRECTORY showing all syncthing conflicts."
  (interactive "D")
  (find-name-dired directory "*.sync-conflict-*"))


(defun ibizaman/syncthing-resolve-conflict-dired (&optional arg)
  "Resolve conflict of first marked file in dired or close to point with ARG."
  (interactive "P")
  (let ((chosen (car (dired-get-marked-files nil arg))))
    (ibizaman/syncthing-resolve-conflict chosen)))


(defun ibizaman/syncthing-resolve-conflict (conflict)
  "Resolve CONFLICT file using ediff."
  (let* ((normal (ibizaman/syncthing--get-normal-filename conflict)))
    (ibizaman/ediff-files
     (list conflict normal)
     `(lambda ()
       (when (y-or-n-p "Delete conflict file? ")
         (kill-buffer (get-file-buffer ,conflict))
         (delete-file ,conflict))))))


(defun ibizaman/syncthing--get-sync-conflicts (directory)
  "Return a list of all sync conflict files in a DIRECTORY."
  (directory-files-recursively directory "\\.sync-conflict-"))


(defvar ibizaman/syncthing--conflict-history
  "Completion conflict history")

(defun ibizaman/syncthing--pick-a-conflict (conflicts)
  "Let user choose the next conflict from CONFLICTS to investigate."
  (completing-read "Choose the conflict to investigate: " conflicts
                   nil t nil ibizaman/syncthing--conflict-history))


(defun ibizaman/syncthing--get-normal-filename (conflict)
  "Get non-conflict filename matching the given CONFLICT."
  (replace-regexp-in-string "\\.sync-conflict-.*\\(\\..*\\)$" "\\1" conflict))


; (message (ibizaman/syncthing--get-normal-filename "hello.sync-conflict-.1234.hs"))


; (message "%s" (ibizaman/syncthing--get-sync-conflicts "~/Projects/mesh"))
#+END_SRC

* In progress
:PROPERTIES:
:HEADER-ARGS: :tangle no
:END:
** Projects
#+BEGIN_SRC emacs-lisp
(defgroup ibizaman/projects nil
  "Projects."
  :group 'convenience)

(defcustom ibizaman/projects-list nil
  "List of projects."
  :group 'ibizaman/projects
  :type '(alist :key-type (directory :tag "Project directory")
                :value-type (group (directory :tag "repository (defaults to project directory)")
                                   (string :tag "jira-url")
                                   (boolean :tag "jira-token"))))

(defcustom ibizaman/projects-nameses-prefix "project"
  "Nameses project prefix."
  :group 'ibizaman/projects
  :type 'string)

(defcustom ibizaman/projects-jira-auth-source-prefix "projects/jira/tokens/"
  "Jira token prefix in auth source."
  :group 'ibizaman/projects
  :type 'string)

(defun ibizaman/projects-add (dirpath &optional repo jira jira-token)
  "Add project with given DIRPATH with NAME with optional JIRA url and REPO.

If JIRA is non empty, it is the url given to jiralib-url.

If REPO is non empty, use that directory as the root for the git
repo.  Defaults to DIRPATH."
  (interactive (let* ((dir (directory-file-name (expand-file-name (read-directory-name "Project directory to add: "))))
                      (repo (directory-file-name (expand-file-name (read-directory-name "Project repo: " dir "." t))))
                      (jira (read-string "Project jira url: "))
                      (jira-token (y-or-n-p (format "Jira needs token (stored in %s%s): "
                                                    ibizaman/projects-jira-auth-source-prefix
                                                    (ibizaman/projects--safe-dir dir)))))
                 (list dir repo jira jira-token)))
  (add-to-list 'ibizaman/projects-list (list dirpath repo jira jira-token)))

(defun ibizaman/projects--project-dir (project)
  "Return PROJECT dir."
  (nth 0 project))

(defun ibizaman/projects--project-repo (project)
  "Return PROJECT repo."
  (or (nth 1 project)
      (ibizaman/projects--project-dir project)))

(defun ibizaman/projects--project-jira (project)
  "Return PROJECT jira url."
  (nth 2 project))

(defun ibizaman/projects--project-jira-token (project)
  "Return PROJECT jira token."
  (auth-source-pass-get 'secret "slack.com/pierre@openmail.co/client-id")
  (nth 3 project))

(defun ibizaman/projects--safe-dir (dir)
  "Return project DIR without special characters."
  (replace-regexp-in-string "/" "_" dir))

(defun ibizaman/projects-find (project-dir)
  "Find project by PROJECT-DIR."
  (when (and project-dir
             (listp ibizaman/projects-list))
    (seq-find (lambda (project)
                (string-equal (ibizaman/projects--safe-dir project-dir)
                              (ibizaman/projects--safe-dir (ibizaman/projects--project-dir project))))
              ibizaman/projects-list)))

(defun ibizaman/projects-current ()
  "Get current project."
  (ibizaman/projects-find (ibizaman/projects--project-dir (ibizaman/projects-task-current))))

(defun ibizaman/projects-load-project (project)
  "Load PROJECT with previous task."
  (nameses-load (format "%s-%s" ibizaman/projects-nameses-prefix (ibizaman/projects--safe-dir (ibizaman/projects--project-dir project)))))

(defun ibizaman/projects-load-task (task &optional project)
  "Load TASK from PROJECT."
  (let ((project-nameses (ibizaman/projects--project-nameses (or project (ibizaman/projects-current)))))
    (nameses-load (format "%s-%s-%s" ibizaman/projects-nameses-prefix project-nameses task))))

(defun ibizaman/projects-switch (project-dir)
  "Switch to project PROJECT-DIR."
  (interactive (let* ((projects (seq-remove
                                 (lambda (elem) (eq (car elem) (ibizaman/projects-current)))
                                 ibizaman/projects-list))
                      (dir (completing-read "Project to switch to: " projects nil t)))
                 (list dir)))
  (let ((project (ibizaman/projects-find project-dir)))
    (when (not project)
      (error "Cannot switch to unknown project %s" project-dir))
    (ibizaman/projects-load-project project)
    (ibizaman/projects-dashboard)))

(defun ibizaman/projects-dashboard ()
  "Go to project dashboard."
  (interactive)
  (let ((project (ibizaman/projects-current)))
    (when (not project)
      (error "No current project"))
    (delete-other-windows)
    (ibizaman/projects-show-magit project)
    (split-window-right)
    (windmove-right)
    (ibizaman/projects-show-jira project)))

(defun ibizaman/projects-show-jira (project)
  "Show jira buffer for PROJECT."
  (interactive)
  (when-let* ((jiralib-url (ibizaman/projects--project-jira project)))
    (let* ((jiralib-token (cons "Cookie" (ibizaman/projects--project-jira-token project)))
           (default-directory (ibizaman/projects--project-dir project))
           (projects-file (expand-file-name "projects-list.org" org-jira-working-dir)))
      (switch-to-buffer (or (find-buffer-visiting projects-file)
                            (find-file projects-file))))))

(defun ibizaman/projects-show-magit (project)
  "Show magit buffer for PROJET."
  (interactive)
  (let ((default-directory (ibizaman/projects--project-repo project))
        (pop-up-window nil)
        (magit--refresh-cache nil))
    (magit-status)))

(defun ibizaman/projects-task-current (&optional current-name)
  "Get current project and task.  Optionally give CURRENT-NAME."
  (let ((name (or current-name (nameses--current-name))))
    (when name
      (when (not (string-match (concat "^" ibizaman/projects-nameses-prefix) name))
        (error "'%s' is not a project handled by Project" name))

      (let ((split (split-string name "-")))
        (pop split)
        (list
         (pop split)
         (when split
           (mapconcat 'identity split "-")))))))

(defun ibizaman/projects-task-live-tasks ()
  "Get list of opened issues and pull requests.

Return a list of cons who's car is the issue or pull request id and
cdr is the displayable name.

The list contains issues and pull requests sorted by descending
number."
  (if-let* ((default-directory (ibizaman/projects--project-repo (ibizaman/projects-current))))
      (sort (map-apply
             (lambda (_ pr)
               (let-alist pr
                 (let ((name (format "%d %s" .number .title)))
                   (cons (replace-regexp-in-string " " "_" name) name))))
             (append (magithub-pull-requests) (magithub-issues)))
            (lambda (a b) (> (string-to-number (car a)) (string-to-number (car b)))))))

(defun ibizaman/projects-task-switch (task)
  "Switch to task under project."
  (interactive (let* ((default-directory (ibizaman/projects--project-repo (ibizaman/projects-current)))
                      (tasks (ibizaman/projects-task-live-tasks))
                      (task (completing-read "task: " tasks nil t)))
                 (list task)))
  (message "%s" task))

(require 'hydra)
(defhydra ibizaman/hydra-projects (:hint nil)
  "
Projects
--------
^On^:   %s(ibizaman/projects--project-dir (ibizaman/projects-current))
^Task^: %s(or (nth 2 (ibizaman/projects-task-current)) \"-\")

 ^Project^        ^Task^        ^Settings^
 _p_: switch      ^t^: switch   _c_: configure
 _d_: dashboard   ^c^: create
 _a_: add
"
  ("p" ibizaman/projects-switch :exit t)
  ("d" ibizaman/projects-dashboard :exit t)
  ("a" ibizaman/projects-add :exit t)
  ("c" (customize-group "ibizaman/projects" t) :exit t))

(global-set-key (kbd "C-c p") #'ibizaman/hydra-projects/body)

;(message "%s" (ibizaman/projects-task-current nil))
;(message "%s" (ibizaman/projects-task-current "hello"))
;(message "%s" (ibizaman/projects-task-current "project-one"))
;(message "%s" (ibizaman/projects-task-current "project-one-task"))
;(message "%s" (ibizaman/projects-task-current "project-one-task-123"))

;(add-hook 'window-configuration-change-hook
;          'balance-windows)

;(message "%s" (magit-name-branch "HEAD"))
;
;
;(defun project-new-task (task-name)
;  (jira
;
;
;(defun project-new-task (task-name)
;  (magit-fetch-all-no-prune)
;  (nameses-save)
;  (magit-branch-and-checkout task-name "origin/master")
;  (nameses-reset))
;
;(defun project-switch-task (task-name)
;  (nameses-save)
;  (magit-checkout task-name)
;  (nameses-reset))
;
;(defun project-select-project (project)
;  (interactive "D")
#+END_SRC
