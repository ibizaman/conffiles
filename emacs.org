* Bootstrapping

#+BEGIN_SRC emacs-lisp
(let ((bootstrap-file (concat user-emacs-directory "straight/repos/straight.el/bootstrap.el"))
      (bootstrap-version 3))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))

(straight-use-package 'use-package)
#+END_SRC

* System
** Mac
#+BEGIN_SRC emacs-lisp
(setq mac-function-key-is-meta t)
(setq mac-function-modifier 'meta)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :straight t
    :config
    (when (memq window-system '(mac ns x))
      (exec-path-from-shell-initialize)))
#+END_SRC

* Helpers
#+BEGIN_SRC emacs-lisp
(defun ibizaman/define-keymap (map-symbol keys)
  (set map-symbol
        (let ((map (make-sparse-keymap)))
          (dolist (key keys)
                  (define-key map (car key) (cdr key)))
          map)))
#+END_SRC

Git-grep command
#+BEGIN_SRC emacs-lisp
(defun completing-read-simple (prompt alist)
  "Equivalent to (completing-read PROMPT ALIST nil nil (car ALIST) (quote ALIST))."
  (completing-read prompt (symbol-value alist) nil nil nil alist))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun call-with-prefix (prefix function)
  "Call a function interactively like if \\<keymap> PREFIX FUNCTION was given."
  (interactive)
  (let ((current-prefix-arg (list prefix)))
    (call-interactively function)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun insert-under (&rest forms)
  (save-excursion
    (move-end-of-line 1)
    (insert (format "\n%s" forms))))
#+END_SRC

** Expand region
#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :straight t
  :bind (("C-c =" . er/expand-region)
	 ("C-c -" . (lambda () (interactive) (call-with-prefix -1 'er/expand-region)))))

(defun use-region-or-expand-region ()
  "Use region if active or expand region at point."
  (when (not (use-region-p))
    (let ((inhibit-message t))
      (call-interactively 'er/expand-region))))
#+END_SRC

** Compilation
#+BEGIN_SRC emacs-lisp
(defun get-region-or-line-content ()
  "Get region or line content."
  (if (use-region-p)
    (buffer-substring-no-properties (region-beginning) (region-end))
    (thing-at-point 'line t)))


(defun compile-region-or-line ()
  "Compile region or line content."
  (interactive)
  (compile (get-region-or-line-content) t))


(global-set-key (kbd "C-c s") 'compile-region-or-line)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(define-key text-mode-map (kbd "C-c C-k") #'kill-current-buffer)
#+END_SRC

* General
** Whitespace
#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

** Saving buffers
Enable saving of minibuffer history and other variables

#+BEGIN_SRC emacs-lisp
(setq savehist-additional-variables '(kill-ring search-ring regexp-search-ring)
      savehist-file "~/.emacs.d/savehist")
(savehist-mode t)
#+END_SRC

** Auto set executable
When saving a file that starts with `#!', make it executable.
#+BEGIN_SRC emacs-lisp
(add-hook 'after-save-hook
	  'executable-make-buffer-file-executable-if-script-p)
#+END_SRC

** Startup
Start frames maximized
#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(fullscreen . maximized))
#+END_SRC

** Font
#+BEGIN_SRC emacs-lisp
(set-face-attribute 'default nil :family "Inconsolata"
                               :foundry "PfEd"
                               :slant 'normal
                               :height 130
                               :weight 'normal
                               :width 'normal)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package command-log-mode
  :straight (command-log-mode :type git :host github :repo "ibizaman/command-log-mode" :branch "master"))
#+END_SRC

** Customization
#+BEGIN_SRC emacs-lisp
; Move custom-set-variables and custom-set-faces in different file
(setq custom-file "~/.emacs-custom.el")
(load custom-file)

; Prompt to save customization before quitting
(add-hook 'kill-emacs-query-functions
	  'custom-prompt-customize-unsaved-options)

(setq backup-directory-alist `(("." . "~/.saves")))

(use-package helpful
  :straight t
  :bind (("C-h f" . #'helpful-callable)
         ("C-h v" . #'helpful-variable)
         ("C-h k" . #'helpful-key)))

(progn
  (global-set-key (kbd "C-h V") #'customize-variable)
  (global-set-key (kbd "C-h G") #'customize-group))
#+END_SRC

** Disable GUI
#+BEGIN_SRC emacs-lisp
(menu-bar-mode 0)
(tool-bar-mode 0)
(when (fboundp 'scroll-bar-mode)
  (scroll-bar-mode 0))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)

(column-number-mode 1)
(setq mode-line-position
      '(;; %p print percent of buffer above top of window, o Top, Bot or All
        ;; (-3 "%p")
        ;; %I print the size of the buffer, with kmG etc
        ;; (size-indication-mode ("/" (-4 "%I")))
        ;; " "
        ;; %l print the current line number
        ;; %c print the current column
        (line-number-mode ("%l" (column-number-mode ":%c")))))
#+END_SRC

** Keyfreq
#+BEGIN_SRC emacs-lisp
(use-package keyfreq
  :straight t
  :config
  (keyfreq-mode 1)
  (keyfreq-autosave-mode 1))
#+END_SRC

** Parenthesis
#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :straight t
  :init
  (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))

; TODO: not in org-mode
(use-package highlight-parentheses
  :straight t
  :config
  (global-highlight-parentheses-mode))
#+END_SRC
** Ibuffer
#+BEGIN_SRC emacs-lisp
(use-package ibuffer
  :straight t
  :bind (("C-x C-b" . 'ibuffer)))
#+END_SRC
** Completion
#+BEGIN_SRC emacs-lisp
(use-package ivy
  :straight t
  :after magit
  :init (global-unset-key (kbd "C-x f"))
  :bind (("C-s" . 'swiper)
         ("C-x f f" . 'counsel-git)
         ("C-x f g" . 'counsel-git-grep))
  :config
  (ivy-mode 1)
  (setq ivy-use-virtual-buffers t)
  (setq ivy-count-format "(%d/%d) ")
  (setq ivy-re-builders-alist
        '((t . ivy--regex-ignore-order)))
  (setq magit-completing-read-function 'ivy-completing-read))

(use-package counsel
  :straight t
  :after ivy
  :config
  (counsel-mode 1))
#+END_SRC

** Emojify
#+BEGIN_SRC emacs-lisp
(use-package emojify
  :straight t)
#+END_SRC
** Ediff
#+BEGIN_SRC emacs-lisp
(defun ediff-buffer-mode-next-difference ()
  "Advance to the next difference."
  (interactive)
  (with-selected-window
      (get-buffer-window "*Ediff Control Panel*")
    (ediff-next-difference)))


(defun ediff-buffer-mode-previous-difference ()
  "Advance to the previous difference."
  (interactive)
  (with-selected-window
      (get-buffer-window "*Ediff Control Panel*")
    (ediff-previous-difference)))


(defun ediff-buffer-mode--get-current-buffer-char ()
  "Get char corresponding to current Ediff buffer."
  (let ((buff (current-buffer)))
    (with-selected-window
        (get-buffer-window "*Ediff Control Panel*")
      (cond ((eq buff ediff-buffer-A) ?a)
            ((eq buff ediff-buffer-B) ?b)
            ((eq buff ediff-buffer-C) ?c)))))


(defun ediff-buffer-mode--get-other-buffer-char (current-buffer-char)
  "For CURRENT-BUFFER-CHAR return other buffer chars."
  (remove current-buffer-char '(?a ?b ?c)))


(defun ediff-buffer-mode--prompt-other-source (current-buffer-char get-or-put)
  "For CURRENT-BUFFER-CHAR, prompt user for other buffer source with prompt adapting to GET-OR-PUT value."
  (let* ((prompt (if (string= get-or-put "get") "Select buffer to get changes from: "
                   "Select buffer to put changes to: "))
         (buffer-help (if (string= get-or-put "get") "Get from "
                        "Put to "))
         (choice
          (read-multiple-choice
           prompt
           (mapcar
            (lambda (char) (list char (concat buffer-help (string char))))
            (ediff-buffer-mode--get-other-buffer-char current-buffer-char)))))
    (car choice)))


(defun ediff-buffer-mode--validate-other-source (current-buffer-char other-buffer-char)
  "For CURRENT-BUFFER-CHAR, check OTHER-BUFFER-CHAR is an accepted char.

For example, for CURRENT-BUFFER-CHAR = ?a then the accepted chars are ?b and ?c."
  (let ((accepted-other-buffers (ediff-buffer-mode--get-other-buffer-char current-buffer-char)))
    (when (not (member other-buffer-char accepted-other-buffers))
      (error "Chosen buffer must be %s" (mapconcat (lambda (x) (string x)) accepted-other-buffers " or ")))))


(defun ediff-buffer-mode-get-changes (&optional get-src)
  "Get changes from the other window into the current window.

For 3-way jobs, the other window cannot be determined automatically.
In that case a prompt will ask the user to enter what buffer the change must come
from.  If GET-SRC is given, use that as the source and do not prompt the user."
  (interactive)
  (let ((buff-char (ediff-buffer-mode--get-current-buffer-char)))
    (with-selected-window
        (get-buffer-window "*Ediff Control Panel*")
      (if ediff-3way-job
          (progn
            (let* ((other-buff-char (ediff-buffer-mode--get-other-buffer-char buff-char))
                   (get-src (or get-src (ediff-buffer-mode--prompt-other-source buff-char "get"))))
              (ediff-buffer-mode--validate-other-source buff-char get-src)
              (cond ((and (char-equal buff-char ?a) (char-equal get-src ?b)) (ediff-copy-B-to-A nil))
                    ((and (char-equal buff-char ?a) (char-equal get-src ?c)) (ediff-copy-C-to-A nil))
                    ((and (char-equal buff-char ?b) (char-equal get-src ?a)) (ediff-copy-A-to-B nil))
                    ((and (char-equal buff-char ?b) (char-equal get-src ?c)) (ediff-copy-C-to-B nil))
                    ((and (char-equal buff-char ?c) (char-equal get-src ?a)) (ediff-copy-A-to-C nil))
                    ((and (char-equal buff-char ?c) (char-equal get-src ?b)) (ediff-copy-B-to-C nil)))))
        (progn
          (cond (char-equal buff-char ?a) (ediff-copy-B-to-A nil)
                (char-equal buff-char ?b) (ediff-copy-A-to-B nil)))))))


(defun ediff-buffer-mode-put-changes (&optional put-src)
  "Get changes from the other window into the current window.

For 3-way jobs, the other window cannot be determined automatically.
In that case a prompt will ask the user to enter what buffer the change must come
from.  If PUT-SRC is given, use that as the source and do not prompt the user."
  (interactive)
  (let ((buff-char (ediff-buffer-mode--get-current-buffer-char)))
    (with-selected-window
        (get-buffer-window "*Ediff Control Panel*")
      (if ediff-3way-job
          (progn
            (let* ((other-buff-char (ediff-buffer-mode--get-other-buffer-char buff-char))
                   (put-src (or put-src (ediff-buffer-mode--prompt-other-source buff-char "put"))))
              (ediff-buffer-mode--validate-other-source buff-char put-src)
              (cond ((and (char-equal buff-char ?a) (char-equal put-src ?b)) (ediff-copy-A-to-B nil))
                    ((and (char-equal buff-char ?a) (char-equal put-src ?c)) (ediff-copy-A-to-C nil))
                    ((and (char-equal buff-char ?b) (char-equal put-src ?a)) (ediff-copy-B-to-A nil))
                    ((and (char-equal buff-char ?b) (char-equal put-src ?c)) (ediff-copy-B-to-C nil))
                    ((and (char-equal buff-char ?c) (char-equal put-src ?a)) (ediff-copy-C-to-A nil))
                    ((and (char-equal buff-char ?c) (char-equal put-src ?b)) (ediff-copy-C-to-B nil)))))
        (progn
          (cond ((char-equal buff-char ?a) (ediff-copy-A-to-B nil))
                ((char-equal buff-char ?b) (ediff-copy-B-to-A nil))))))))


(defvar ediff-buffer-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "C-j") 'ediff-buffer-mode-next-difference)
    (define-key map (kbd "C-k") 'ediff-buffer-mode-previous-difference)
    (define-key map (kbd "C-c o") 'ediff-buffer-mode-get-changes)
    (define-key map (kbd "C-c p") 'ediff-buffer-mode-put-changes)
    map))


(define-minor-mode ediff-buffer-mode
  "Minor mode enabled on buffers used in Ediff."
  :init-value nil)


(defun enable-ediff-buffer-mode ()
  "Enable ediff=buffer-mode."
  (ediff-buffer-mode t))


(defun disable-all-ediff-buffer-mode ()
  "Enable ediff=buffer-mode."
  (with-selected-window
      (get-buffer-window "*Ediff Control Panel*")
    (if ediff-buffer-A
        (with-selected-window (get-buffer-window ediff-buffer-A)
          (ediff-buffer-mode -1)))
    (if ediff-buffer-B
        (with-selected-window (get-buffer-window ediff-buffer-B)
          (ediff-buffer-mode -1)))
    (if ediff-buffer-C
        (with-selected-window (get-buffer-window ediff-buffer-C)
          (ediff-buffer-mode -1)))))


(add-hook 'ediff-prepare-buffer-hook 'enable-ediff-buffer-mode)
(add-hook 'ediff-cleanup-hook 'disable-all-ediff-buffer-mode)
#+END_SRC
** Occur
#+BEGIN_SRC emacs-lisp
(progn
  (defun occur-dwim ()
    "Call `occur' with the symbol under point or selected region as default."
    (interactive)
    (push (if (region-active-p)
              (buffer-substring-no-properties
               (region-beginning)
               (region-end))
            (let ((sym (thing-at-point 'symbol)))
              (when (stringp sym)
                (regexp-quote sym))))
          regexp-history)
    (call-interactively 'occur))

  ;; Focus on *Occur* window right away.
  (add-hook 'occur-hook (lambda () (other-window 1)))

  (defun reattach-occur ()
    (if (get-buffer "*Occur*")
        (switch-to-buffer-other-window "*Occur*")
      (hydra-occur-dwim/body) )))
#+END_SRC
* Org
** Install latest version

ORG-MODE install hack https://github.com/raxod502/straight.el/commit/3190d95ee0556233624a4fb3bd2342e1fcb516b1#diff-04c6e90faac2675aa89e2176d2eec7d8

#+BEGIN_SRC emacs-lisp
(require 'subr-x)
(straight-use-package 'git)

(defun org-git-version ()
  "The Git version of 'org-mode'.
Inserted by installing 'org-mode' or when a release is made."
  (require 'git)
  (let ((git-repo (expand-file-name
                   "straight/repos/org/" user-emacs-directory)))
    (string-trim
     (git-run "describe"
              "--match=release\*"
              "--abbrev=6"
              "HEAD"))))

(defun org-release ()
  "The release version of 'org-mode'.
Inserted by installing 'org-mode' or when a release is made."
  (require 'git)
  (let ((git-repo (expand-file-name
                   "straight/repos/org/" user-emacs-directory)))
    (string-trim
     (string-remove-prefix
      "release_"
      (git-run "describe"
               "--match=release\*"
               "--abbrev=0"
               "HEAD")))))

(provide 'org-version)

(straight-use-package 'org)
#+END_SRC

** Configure
#+BEGIN_SRC emacs-lisp
(use-package org
  :straight t
  :after evil
  :init
  (defun my/org-mode-hook-evil ()
      (setq evil-auto-indent nil))
  (add-hook 'org-mode-hook 'my/org-mode-hook-evil)
  :config
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (sql . t)
     (python . t)
     (shell . t)))

  (progn
    (defun ibizaman/org-copy-element ()
      (interactive)
      (let* ((elem (org-element-at-point))
             (beg (org-element-property :begin elem))
             (end (org-element-property :end elem)))
        (copy-region-as-kill beg end)
        (goto-char end))))

  (setq org-log-done 'time)

  (evil-define-key 'normal org-mode-map (kbd "<tab>") 'org-cycle)
  :bind (("C-c j" . outline-next-heading)
         ("C-c k" . outline-previous-heading)
         ("C-c h" . outline-up-heading)
         ("C-c l" . outline-show-subtree)
         :map org-mode-map
         ("C-c o d" . org-cut-element)
         ("C-c o c" . ibizaman/org-copy-element)
         ("<tab>" . org-cycle)))
#+END_SRC

** Babel
#+BEGIN_SRC emacs-lisp
(use-package ob-async
  :straight t
  :after org)

(use-package ob-python
  :after org)

(use-package ob-shell
  :after org)

(use-package ob-tmux
  :straight (ob-tmux :type git :host nil :repo "https://github.com/ahendriksen/ob-tmux.git")
  :config
  (setq org-babel-default-header-args:tmux
        '((:results . "silent")
          (:terminal . "iterm")))
  (setq org-babel-tmux-session-prefix "ob-"))

(use-package ox-hugo
  :straight t
  :after ox)
#+END_SRC

* Eshell
#+BEGIN_SRC emacs-lisp
(use-package eshell
  :hook
  (defun ibizaman/eshell-imenu-expression ()
    (setq-local imenu-generic-expression
                '(("Prompt" " $ \\(.*\\)" 1))))
  (add-hook 'eshell-mode-hook 'ibizaman/eshell-imenu-expression))
#+END_SRC
* Layout
#+BEGIN_SRC emacs-lisp
(winner-mode)
#+END_SRC

With truncate-lines, do not split word
#+BEGIN_SRC emacs-lisp
(setq visual-line-mode 1)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package mustang-theme
  :straight t)
#+END_SRC

** Modeline
#+BEGIN_SRC emacs-lisp
(defun shorten-directory (dir max-length)
  "Show up to `max-length' characters of a directory name `dir'."
  (let ((path (reverse (split-string (abbreviate-file-name dir) "/")))
               (output ""))
       (when (and path (equal "" (car path)))
         (setq path (cdr path)))
       (while (and path (< (length output) (- max-length 4)))
         (setq output (concat (car path) "/" output))
         (setq path (cdr path)))
       (when path
         (setq output (concat ".../" output)))
       output))


(setq-default mode-line-buffer-identification
  (propertized-buffer-identification "%b "))

(setq-default mode-line-format
      '("%e"
        mode-line-front-space
        ;; mode-line-mule-info -- I'm always on utf-8
        mode-line-client
        mode-line-modified
        ;; mode-line-remote -- no need to indicate this specially
        ;; mode-line-frame-identification -- this is for text-mode emacs only
        " "
        mode-line-directory
        mode-line-buffer-identification
        " "
        mode-line-position
        ;; (vc-mode vc-mode)  -- I use magit, not vc-mode
        ;; (flycheck-mode flycheck-mode-line)
        " "
        ;; mode-line-modes
        mode-line-misc-info
        mode-line-end-spaces))
#+END_SRC

* Evil
#+BEGIN_SRC emacs-lisp
(use-package evil
  :straight t
  :init
  (setq evil-want-C-u-scroll t
        ; Warning (evil-collection): Make sure to set
        ; `evil-want-keybinding' to nil before loading evil or
        ; evil-collection.  See
        ; https://github.com/emacs-evil/evil-collection/issues/60 for
        ; more details.
        evil-want-keybinding nil)
  (define-key global-map (kbd "C-i") 'universal-argument)
  (define-key universal-argument-map (kbd "C-i") 'universal-argument-more)
  :config
  (evil-mode 1)
  (global-unset-key (kbd "C-x +")) ; Set to "C-w =" with evil
  )

(use-package evil-collection
  :straight t
  :after evil
  :config
  (evil-collection-init))

(use-package evil-textobj-syntax
  :straight t)

(use-package evil-textobj-column
  :straight t
  :bind (:map evil-inner-text-objects-map
         ("c" . evil-textobj-column-word)
         ("C" . evil-textobj-column-WORD)))
#+END_SRC

* Magit
#+BEGIN_SRC emacs-lisp
(use-package magit-gh-pulls
  :straight t)

(use-package evil-magit
  :straight t)

(use-package magit
  :straight t
  :after magit-gh-pulls
  :init
  (setq magit-diff-refine-hunk t
	magit-diff-paint-whitespace t
	magit-diff-highlight-trailing t
	magit-process-popup-time 10
	magit-save-repository-buffers t
	magit-push-current-set-remote-if-missing t)
  :bind (("C-x g" . magit-status))
  :config
  (progn
    (defun ibizaman/magit-lone-branches ()
      (let* ((cmd-output (magit-with-toplevel
                           (shell-command-to-string "git for-each-ref --format='%(refname:short) %(upstream)' refs/heads")))
             (branches (split-string cmd-output "\n"))
             (lone-branches (seq-filter (lambda (elt) (= 1 (length (split-string elt)))) branches)))
        (seq-map (lambda (elt) (car (split-string elt))) lone-branches)))

    (defun ibizaman/magit-get-ref (name)
      (let* ((cmd (concat "git show-ref --hash " name))
             (all-sha1 (magit-with-toplevel (shell-command-to-string cmd))))
        (car (split-string all-sha1))))

    (defun ibizaman/magit-merged-branchp (branch &optional master)
      (let* ((master (or master "origin/master"))
             (master-sha1 (ibizaman/magit-get-ref master))
             (branch-sha1 (ibizaman/magit-get-ref branch)))
        (= 0 (magit-with-toplevel (call-process "git" nil nil nil "merge-base" "--is-ancestor" branch-sha1 master-sha1)))))

    (defun ibizaman/magit-clean-lone-branch (&optional branch-to-clean)
      (interactive
       (list (completing-read "Select lone branch to clean:" (seq-filter 'ibizaman/magit-merged-branchp (ibizaman/magit-lone-branches))))))))


(use-package magithub
  :straight (magithub :type git :host github :repo "vermiculus/magithub" :branch "master")
  :after magit
  :config
  (magithub-feature-autoinject t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package git-link
  :straight t
  :config
  (defun git-link-master-branch ()
    (interactive)
    (let ((git-link-default-branch "master"))
      (call-interactively 'git-link)))
  (defun git-link-at-commit ()
    (interactive)
    (let ((git-link-use-commit t))
      (call-interactively 'git-link)))
  (defun git-link-master-branch-at-commit ()
    (interactive)
    (let ((git-link-default-branch "master")
	  (git-link-use-commit t))
      (call-interactively 'git-link))))

(use-package git-gutter-fringe+
  :straight t
  :after git-gutter+
  :config
  (global-git-gutter+-mode)
  (git-gutter-fr+-minimal)
  (setq git-gutter-fr+-side 'right-fringe))
#+END_SRC

* Python
#+BEGIN_SRC emacs-lisp
(use-package pyenv-mode
  :straight t
  :config
  (pyenv-mode)
  (defun ibizaman/pyenv-virtualenv-create (&optional env name)
    (interactive (list (completing-read "What python version to use: " (pyenv-mode-versions))
                       (read-string "Name of the new virtualenv: "))))
  (ibizaman/define-keymap
   'pyenv-mode-map
   `((,(kbd "C-c p p") . pyenv-mode-set)
     (,(kbd "C-c p u") . pyenv-mode-unset)
     (,(kbd "C-c p c") . ibizaman/pyenv-virtualenv-create))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package pytest
  :straight t
  :bind (("C-c t t" . pytest-one)
	 ("C-c t m" . pytest-module)))
#+END_SRC

* SQL
#+BEGIN_SRC emacs-lisp
(use-package sql-indent
  :straight t)
#+END_SRC

* Linting
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :straight t
  :config
  (setq flycheck-command-wrapper-function
        (lambda (command)
          (if (null (string-match "pylint" (car command)))
              command
	    (let* ((new-prefix (replace-regexp-in-string "pylint$" "python" (car command)))
		   (new-rest (append '("-m" "pylint") (cdr command)))
		   (new-command (append (list new-prefix) new-rest)))
	      new-command))))
  (global-flycheck-mode))

(use-package flycheck-popup-tip
  :straight t
  :after flycheck
  :config
  (flycheck-popup-tip-mode))
#+END_SRC

* Spelling
TODO: slow in org-mode
#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :config
  (progn
    (add-hook 'text-mode-hook #'turn-on-flyspell)
    (add-hook 'org-mode-hook #'turn-on-flyspell)
    (add-hook 'prog-mode-hook 'flyspell-prog-mode))
  (setq flyspell-issue-message-flag nil)  ; speedup checking entire buffer
  )

(use-package ispell
  :config
  (setq ispell-program-name "hunspell"
        ispell-local-dictionary "fr"))
#+END_SRC

* Autocompletion
#+BEGIN_SRC emacs-lisp
(use-package company-jedi
  :straight t
  :init
  (defun my/python-mode-hook-company-jedi ()
    (add-to-list 'company-backends 'company-jedi))
  (add-hook 'python-mode-hook 'my/python-mode-hook-company-jedi))

(use-package company
  :straight t
  :init
  (add-hook 'after-init-hook 'global-company-mode))
#+END_SRC

* Languages
** Json
#+BEGIN_SRC emacs-lisp
(use-package json-mode
  :straight t)
#+END_SRC

** Yaml
#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
#+END_SRC

** Html
#+BEGIN_SRC emacs-lisp
(use-package htmlize
  :straight t)
#+END_SRC

** Groovy
#+BEGIN_SRC emacs-lisp
(use-package groovy-mode
  :straight t)
#+END_SRC

** Markdown
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :straight t)
#+END_SRC

** Elisp
#+BEGIN_SRC emacs-lisp
(defun eval-point-region-and-deactivate ()
  "Evaluate region or expanded region and deactivates region when done."
  (interactive)
  (use-region-or-expand-region)
  (condition-case-unless-debug err
      (call-interactively 'eval-region)
    (error (deactivate-mark)
           (signal (car err) (cdr err))))
  (deactivate-mark))


(use-package elisp-mode
  :bind (("C-c C-c" . eval-point-region-and-deactivate)))
#+END_SRC

** Elm
#+BEGIN_SRC emacs-lisp
(defun ibizaman/elm-mode-hook ()
  (set (make-local-variable 'eldoc-documentation-function)
       'elm-oracle-type-at-point))

(use-package elm-mode
  :straight t
  :config
  (add-hook 'elm-mode-hook #'ibizaman/elm-mode-hook))

(use-package flycheck-elm
  :straight t
  :after flycheck
  :init
  (add-hook 'flycheck-mode-hook #'flycheck-elm-setup))
#+END_SRC

** Haskell
#+BEGIN_SRC emacs-lisp
(use-package haskell-mode
  :straight t)

(use-package intero
  :straight t
  :config
  (intero-global-mode 1))
#+END_SRC

** Systemd
#+BEGIN_SRC emacs-lisp
(use-package systemd
  :straight t)
#+END_SRC

** Package Manager
#+BEGIN_SRC emacs-lisp
(use-package system-packages
  :straight t)
#+END_SRC

** Graphviz
#+BEGIN_SRC emacs-lisp
(use-package graphviz-dot-mode
  :straight t)
#+END_SRC

** Docker
#+BEGIN_SRC emacs-lisp
(use-package docker
  :straight t)

(use-package dockerfile-mode
  :straight t)
#+END_SRC
* Secrets
#+BEGIN_SRC emacs-lisp
(use-package pass
  :straight t)

(use-package auth-source)

(use-package auth-source-pass
  :straight t
  :config
  (auth-source-pass-enable))
#+END_SRC

* Email

Install instructions:
#+BEGIN_SRC bash
git clone git://github.com/djcb/mu.git
cd mu
brew install gmime
./autogen.sh && ./configure && make
sudo make install
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/straight/repos/mu4e/mu4e")
(use-package mu4e
  :config
  (require 'mu4e-contrib)

  (progn
    (defcustom ibizaman/mu4e-unread-excluded-lists nil
      "Mailing lists to be excluded from default unread view."
      :group 'mu4e
      :type '(repeat string))

    (defun ibizaman/mu4e-add-message-list-to-excluded-lists (msg)
      (let ((list (mu4e-message-field msg :mailing-list)))
        (add-to-list 'ibizaman/mu4e-unread-excluded-lists list)
        (message "Added %s to excluded list" list)))

    (add-to-list 'mu4e-headers-actions
                 '("Exclude list" . ibizaman/mu4e-add-message-list-to-excluded-lists) t)

    (defun ibizaman/mu4e-generate-unread-filter ()
      (concat "flag:unread "
              "AND NOT flag:trashed "
              "AND NOT maildir:/Gmail/recruiting "
              "AND NOT maildir:\"/Gmail/[Google Mail].Trash\" "
              "AND NOT maildir:\"/Gmail/[Google Mail].Spam\" "
              (mapconcat (lambda (v) (concat " AND NOT list:" v))
                         ibizaman/mu4e-unread-excluded-lists "")))

    (defun ibizaman/mu4e-get-unread-list-filter-query (wanted-list)
      (interactive (list (completing-read "List: " ibizaman/mu4e-unread-excluded-lists)))
      (concat "flag:unread AND NOT flag:trashed AND list:" wanted-list)))

  (setq mail-user-agent        'mu4e-user-agent
        mu4e-maildir           "~/Maildir"
        mu4e-use-fancy-chars   t
        mu4e-attachment-dir    "~/Maildir/Attachments/Gmail"
        mu4e-view-show-images  t
        mu4e-confirm-quit      nil
        mu4e-completing-read-function 'ivy-completing-read
        mu4e-hide-index-messages t
        message-kill-buffer-on-exit   t
        mu4e-html2text-command 'mu4e-shr2text
        shr-color-visible-luminance-min 80  ; for dark themes
        shr-color-visible-distance-min 5
        mu4e-refile-folder "/Gmail/[Google Mail].All Mail")
  (defun ibizaman/mu4e-set-contexts ()
    (setq mu4e-contexts
          `( ,(make-mu4e-context
               :name "Private"
               :enter-func (lambda () (mu4e-message "Entering Private context"))
               :leave-func (lambda () (mu4e-message "Leaving Private context"))
               ;; we match based on the contact-fields of the message
               :match-func (lambda (msg)
                             (when msg
                               (string-match-p "^/Gmail" (mu4e-message-field msg :maildir))))
               :vars `( ( user-mail-address      . "ibizapeanut@gmail.com"  )
                        ( user-full-name         . "Pierre Penninckx" )
                        ( mu4e-drafts-folder     . "/Gmail/[Google Mail].Drafts" )
                        ( mu4e-sent-folder       . "/Gmail/[Google Mail].Sent Mail" )
                        ( mu4e-trash-folder      . "/Gmail/[Google Mail].Trash" )
                        ;; don't save message to Sent Messages, Gmail/IMAP takes care of this
                        ( mu4e-sent-messages-behavior . delete )
                        ( mu4e-maildir-shortcuts .
                                                 ( ("/Gmail/INBOX"                     . ?i)
                                                   ("/Gmail/recruiting"                . ?r)
                                                   ("/Gmail/[Google Mail].Sent Mail"   . ?s)
                                                   ("/Gmail/[Google Mail].Trash"       . ?t)
                                                   ("/Gmail/[Google Mail].All Mail"    . ?a)) )
                        ( mu4e-get-mail-command . "offlineimap" )
                        ( mu4e-bookmarks .
                                         (,(make-mu4e-bookmark
                                            :name  "Unread messages not list"
                                            :query (lambda () (ibizaman/mu4e-generate-unread-filter))
                                            :key ?u)
                                          ,(make-mu4e-bookmark
                                            :name  "Recruiting"
                                            :query "maildir:/Gmail/recruiting"
                                            :key ?r)
                                          ,(make-mu4e-bookmark
                                            :name  "Unread messages all"
                                            :query (concat "flag:unread "
                                                           "AND NOT flag:trashed"
                                                           "AND NOT maildir:\"/Gmail/[Google Mail].Trash\" "
                                                           "AND NOT maildir:\"/Gmail/[Google Mail].Spam\" ")
                                            :key ?i)
                                          ,(make-mu4e-bookmark
                                            :name  "Unread list messages"
                                            :query (lambda () (call-interactively 'ibizaman/mu4e-get-unread-list-filter-query))
                                            :key ?l)
                                          ,(make-mu4e-bookmark
                                            :name "Today's messages"
                                            :query "date:today..now"
                                            :key ?t)
                                          ,(make-mu4e-bookmark
                                            :name "Last 7 days"
                                            :query "date:7d..now AND NOT flag:list AND NOT maildir:/Gmail/recruiting"
                                            :key ?w)
                                          ,(make-mu4e-bookmark
                                            :name "Messages with images"
                                            :query "mime:image/*"
                                            :key ?p)
                                          ,(make-mu4e-bookmark
                                            :name "Drafts"
                                            :query "flag:draft"
                                            :key ?d))))))))
  (ibizaman/mu4e-set-contexts)

  (require 'smtpmail)
  (setq message-send-mail-function 'smtpmail-send-it
        user-mail-address "ibizapeanut@gmail.com"
        starttls-use-gnutls t
        starttls-gnutls-program "gnutls-cli"
        starttls-extra-arguments nil
        smtpmail-default-smtp-server "smtp.gmail.com"
        smtpmail-smtp-server "smtp.gmail.com"
        smtpmail-smtp-service 587
        smtpmail-debug-info t
        smtpmail-smtp-user "ibizapeanut@gmail.com"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package org-mu4e
  :after org mu4e)
#+END_SRC

* Workspace
#+BEGIN_SRC emacs-lisp
(use-package nameses
  :straight (nameses :type git :host nil :repo "https://gist.github.com/8960595.git")
  :init (require 'desktop))

(defun nameses-create ()
  (interactive)
  (let ((current-prefix-arg '(4)))
    (call-interactively 'nameses-load)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package eyebrowse
  :straight t
  :config
  (setq eyebrowse-new-workspace t)
  (eyebrowse-mode 1))
#+END_SRC

* Slack
#+BEGIN_SRC emacs-lisp
(use-package slack
  :straight t
  :commands (slack-start)
  :init
  (setq slack-buffer-emojify t
        slack-prefer-current-team t
        slack-completing-read-function #'ivy-completing-read
        slack-buffer-function #'switch-to-buffer
        slack-display-team-name nil
        slack-request-timeout 100)
  :config
  (slack-register-team
   :name "emacs-slack"
   :default t
   :client-id (auth-source-pass-get 'secret "slack.com/pierre@openmail.co/client-id")
   :client-secret (auth-source-pass-get 'secret "slack.com/pierre@openmail.co/client-secret")
   :token (auth-source-pass-get 'secret "slack.com/pierre@openmail.co/token")
   :full-and-display-names t)
  :bind (("C-j" . #'slack-buffer-goto-next-message)
         ("C-k" . #'slack-buffer-goto-prev-message)))
#+END_SRC

* Jira
#+BEGIN_SRC emacs-lisp
(use-package org-jira
  :straight (org-jira :type git :host nil :repo "https://github.com/ahungry/org-jira.git"))
#+END_SRC

* Hydra

#+BEGIN_SRC emacs-lisp
(use-package hydra
  :straight t
  :after ibuffer)
#+END_SRC

** occur
#+BEGIN_SRC emacs-lisp
(progn
  ;; Keeps focus on *Occur* window, even when when target is visited via RETURN key.
  ;; See hydra-occur-dwim for more options.
  (defadvice occur-mode-goto-occurrence (after occur-mode-goto-occurrence-advice activate)
    (other-window 1)
    (hydra-occur-dwim/body))

  ;; Used in conjunction with occur-mode-goto-occurrence-advice this helps keep
  ;; focus on the *Occur* window and hides upon request in case needed later.
  (defhydra hydra-occur-dwim ()
    "Occur mode"
    ("o" occur-dwim "Start occur-dwim" :color red)
    ("j" occur-next "Next" :color red)
    ("k" occur-prev "Prev":color red)
    ("h" delete-window "Hide" :color blue)
    ("r" (reattach-occur) "Re-attach" :color red))

  (global-set-key (kbd "C-x o") 'hydra-occur-dwim/body))
#+END_SRC

** dired
#+BEGIN_SRC emacs-lisp
(require 'dired)

(defhydra hydra-dired (:hint nil :color pink)
  "
_+_ mkdir          _v_iew           _m_ark             _(_ details        _i_nsert-subdir    wdired
_C_opy             _O_ view other   _U_nmark all       _)_ omit-mode      _$_ hide-subdir    C-x C-q : edit
_D_elete           _o_pen other     _u_nmark           _l_ redisplay      _w_ kill-subdir    C-c C-c : commit
_R_ename           _M_ chmod        _t_oggle           _g_ revert buf     _e_ ediff          C-c ESC : abort
_Y_ rel symlink    _G_ chgrp        _E_xtension mark   _s_ort             _=_ pdiff
_S_ymlink          ^ ^              _F_ind marked      _._ toggle hydra   \\ flyspell
_r_sync            ^ ^              ^ ^                ^ ^                _?_ summary
_z_ compress-file  _A_ find regexp
_Z_ compress       _Q_ repl regexp

T - tag prefix
"
  ("\\" dired-do-ispell)
  ("(" dired-hide-details-mode)
  (")" dired-omit-mode)
  ("+" dired-create-directory)
  ("=" diredp-ediff)         ;; smart diff
  ("?" dired-summary)
  ("$" diredp-hide-subdir-nomove)
  ("A" dired-do-find-regexp)
  ("C" dired-do-copy)        ;; Copy all marked files
  ("D" dired-do-delete)
  ("E" dired-mark-extension)
  ("e" dired-ediff-files)
  ("F" dired-do-find-marked-files)
  ("G" dired-do-chgrp)
  ("g" revert-buffer)        ;; read all directories again (refresh)
  ("i" dired-maybe-insert-subdir)
  ("l" dired-do-redisplay)   ;; relist the marked or singel directory
  ("M" dired-do-chmod)
  ("m" dired-mark)
  ("O" dired-display-file)
  ("o" dired-find-file-other-window)
  ("Q" dired-do-find-regexp-and-replace)
  ("R" dired-do-rename)
  ("r" dired-do-rsynch)
  ("S" dired-do-symlink)
  ("s" dired-sort-toggle-or-edit)
  ("t" dired-toggle-marks)
  ("U" dired-unmark-all-marks)
  ("u" dired-unmark)
  ("v" dired-view-file)      ;; q to exit, s to search, = gets line #
  ("w" dired-kill-subdir)
  ("Y" dired-do-relsymlink)
  ("z" diredp-compress-this-file)
  ("Z" dired-do-compress)
  ("q" nil)
  ("." nil :color blue))

(define-key dired-mode-map (kbd ".") #'hydra-dired/body)
#+END_SRC

** flycheck
#+BEGIN_SRC emacs-lisp
(defhydra hydra-flycheck
  (:pre (progn (setq hydra-lv t) (flycheck-list-errors))
        :post (progn (setq hydra-lv nil) (quit-windows-on "*Flycheck errors*"))
        :hint nil)
  "Errors"
  ("f"  flycheck-error-list-set-filter                            "Filter")
  ("j"  flycheck-next-error                                       "Next")
  ("k"  flycheck-previous-error                                   "Previous")
  ("gg" flycheck-first-error                                      "First")
  ("G"  (progn (goto-char (point-max)) (flycheck-previous-error)) "Last")
  ("q"  nil))

(global-set-key (kbd "C-c f") 'hydra-flycheck/body)
#+END_SRC

** ibuffer
#+BEGIN_SRC emacs-lisp
(defhydra hydra-ibuffer-main (:color pink :hint nil)
  "
^Mark^         ^Actions^         ^View^          ^Select^              ^Navigation^
_m_: mark      _D_: delete       _g_: refresh    _q_: quit             _k_:   ↑    _h_
_u_: unmark    _s_: save marked  _S_: sort       _TAB_: toggle         _RET_: visit
_*_: specific  _a_: all actions  _/_: filter     _o_: other window     _j_:   ↓    _l_
_t_: toggle    _._: toggle hydra _H_: help       C-o other win no-select
"
  ("m" ibuffer-mark-forward)
  ("u" ibuffer-unmark-forward)
  ("*" hydra-ibuffer-mark/body :color blue)
  ("t" ibuffer-toggle-marks)

  ("D" ibuffer-do-delete)
  ("s" ibuffer-do-save)
  ("a" hydra-ibuffer-action/body :color blue)

  ("g" ibuffer-update)
  ("S" hydra-ibuffer-sort/body :color blue)
  ("/" hydra-ibuffer-filter/body :color blue)
  ("H" describe-mode :color blue)

  ("h" ibuffer-backward-filter-group)
  ("k" ibuffer-backward-line)
  ("l" ibuffer-forward-filter-group)
  ("j" ibuffer-forward-line)
  ("RET" ibuffer-visit-buffer :color blue)

  ("TAB" ibuffer-toggle-filter-group)

  ("o" ibuffer-visit-buffer-other-window :color blue)
  ("q" quit-window :color blue)
  ("." nil :color blue))

(defhydra hydra-ibuffer-mark (:color teal :columns 5
                                     :after-exit (hydra-ibuffer-main/body))
  "Mark"
  ("*" ibuffer-unmark-all "unmark all")
  ("M" ibuffer-mark-by-mode "mode")
  ("m" ibuffer-mark-modified-buffers "modified")
  ("u" ibuffer-mark-unsaved-buffers "unsaved")
  ("s" ibuffer-mark-special-buffers "special")
  ("r" ibuffer-mark-read-only-buffers "read-only")
  ("/" ibuffer-mark-dired-buffers "dired")
  ("e" ibuffer-mark-dissociated-buffers "dissociated")
  ("h" ibuffer-mark-help-buffers "help")
  ("z" ibuffer-mark-compressed-file-buffers "compressed")
  ("b" hydra-ibuffer-main/body "back" :color blue))

(defhydra hydra-ibuffer-action (:color teal :columns 4
                                       :after-exit
                                       (if (eq major-mode 'ibuffer-mode)
                                           (hydra-ibuffer-main/body)))
  "Action"
  ("A" ibuffer-do-view "view")
  ("E" ibuffer-do-eval "eval")
  ("F" ibuffer-do-shell-command-file "shell-command-file")
  ("I" ibuffer-do-query-replace-regexp "query-replace-regexp")
  ("H" ibuffer-do-view-other-frame "view-other-frame")
  ("N" ibuffer-do-shell-command-pipe-replace "shell-cmd-pipe-replace")
  ("M" ibuffer-do-toggle-modified "toggle-modified")
  ("O" ibuffer-do-occur "occur")
  ("P" ibuffer-do-print "print")
  ("Q" ibuffer-do-query-replace "query-replace")
  ("R" ibuffer-do-rename-uniquely "rename-uniquely")
  ("T" ibuffer-do-toggle-read-only "toggle-read-only")
  ("U" ibuffer-do-replace-regexp "replace-regexp")
  ("V" ibuffer-do-revert "revert")
  ("W" ibuffer-do-view-and-eval "view-and-eval")
  ("X" ibuffer-do-shell-command-pipe "shell-command-pipe")
  ("b" nil "back"))

(defhydra hydra-ibuffer-sort (:color amaranth :columns 3)
  "Sort"
  ("i" ibuffer-invert-sorting "invert")
  ("a" ibuffer-do-sort-by-alphabetic "alphabetic")
  ("v" ibuffer-do-sort-by-recency "recently used")
  ("s" ibuffer-do-sort-by-size "size")
  ("f" ibuffer-do-sort-by-filename/process "filename")
  ("m" ibuffer-do-sort-by-major-mode "mode")
  ("b" hydra-ibuffer-main/body "back" :color blue))

(defhydra hydra-ibuffer-filter (:color amaranth :columns 4)
  "Filter"
  ("m" ibuffer-filter-by-used-mode "mode")
  ("M" ibuffer-filter-by-derived-mode "derived mode")
  ("n" ibuffer-filter-by-name "name")
  ("c" ibuffer-filter-by-content "content")
  ("e" ibuffer-filter-by-predicate "predicate")
  ("f" ibuffer-filter-by-filename "filename")
  (">" ibuffer-filter-by-size-gt "size")
  ("<" ibuffer-filter-by-size-lt "size")
  ("/" ibuffer-filter-disable "disable")
  ("b" hydra-ibuffer-main/body "back" :color blue))

(define-key ibuffer-mode-map (kbd "?") 'hydra-ibuffer-main/body)
(add-hook 'ibuffer-hook #'hydra-ibuffer-main/body)
#+END_SRC

** info
#+BEGIN_SRC emacs-lisp
(defhydra hydra-info (:color pink
                             :hint nil)
  "
Info-mode:
_I_ndex(virtual)    _T_OC                            ^ ^^ ^  ^ ^ ^^     _k_/_u_p   ( )
_i_ndex             _t_op node        Node           _[__h_ + _l__]_      _j_/_m_enu ( ) (C-u for new window)
_c_opy node name    _a_propos         Top/Final Node _<__t_   ^ ^_>_      _g_oto node^^    (C-u for new window)
_C_lone buffer      _f_ollow          Level nxt/prev _p_^ ^   ^ ^_n_
_d_irectory         _b_mkp-jump       History        _H_^ ^   ^ ^_L_      _K_ History^^

_s_earch regex (_S_ case sens) ^^^^   _1_ .. _9_ Pick first .. ninth item in the node's menu.
"
  ("j"   Info-menu)              ;; m
  ("k"   Info-up)                ;; ^
  ("m"   Info-menu)
  ("u"   Info-up)

  ("l"   Info-forward-node)
  ("h"   Info-backward-node)
  ("]"   Info-forward-node)
  ("["   Info-backward-node)

  ("t"   Info-top-node)
  ("<"   Info-top-node)
  (">"   Info-final-node)

  ("n"   Info-next)
  ("p"   Info-prev)

  ("K"   Info-history)
  ("H"   Info-history-back)
  ("L"   Info-history-forward)

  ("s"   Info-search)
  ("S"   Info-search-case-sensitively)

  ("g"   Info-goto-node)

  ("f"   Info-follow-reference)
  ("b"   bmkp-info-jump)
  ("i"   Info-index)
  (","   Info-index-next)
  ("I"   Info-virtual-index)

  ("T"   Info-toc)
  ("t"   Info-top-node)
  ("d"   Info-directory)
  ("c"   Info-copy-current-node-name)
  ("C"   clone-buffer)
  ("a"   info-apropos)

  ("1"   Info-nth-menu-item)
  ("2"   Info-nth-menu-item)
  ("3"   Info-nth-menu-item)
  ("4"   Info-nth-menu-item)
  ("5"   Info-nth-menu-item)
  ("6"   Info-nth-menu-item)
  ("7"   Info-nth-menu-item)
  ("8"   Info-nth-menu-item)
  ("9"   Info-nth-menu-item)

  ("?"   Info-summary "Info summary")
  ("y"   Info-help "Info help")
  ("q"   Info-exit "Info exit" :color blue)
  ("C-g" nil "cancel" :color blue))

(define-key Info-mode-map (kbd "?") #'hydra-info/body)
#+END_SRC

** nameses
#+BEGIN_SRC emacs-lisp
(defun hydra-nameses-format (value)
  (truncate-string-to-width (format "%s" value) 15 nil ? t))

(defhydra hydra-nameses (:exit t :hint nil)
  "
^Current^: %s(hydra-nameses-format (nameses--current-name))       _s_ave
      _p_: load %s(hydra-nameses-format nameses-prev-session)  ^^^_n_ew
      _d_: load                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^_k_ remove
      _r_eset                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^_q_uit
"
  ("s" nameses-save)
  ("p" nameses-prev)
  ("k" nameses-remove :exit nil)
  ("r" nameses-reset)
  ("d" nameses-load)
  ("n" nameses-create)
  ("q" nil))

(global-set-key (kbd "C-c d") 'hydra-nameses/body)
#+END_SRC

** org-jira
#+BEGIN_SRC emacs-lisp
(progn
  (defhydra hydra-org-jira-project (:exit t)
    "Org-jira project"
    ("g" org-jira-get-projects "refresh"))

  (defhydra hydra-org-jira-board (:exit t)
    "Org-jira board"
    ("g" org-jira-get-boards "refresh"))

  (defhydra hydra-org-jira-issue (:exit t)
    "Org-jira board"
    ("g" org-jira-get-issues "get all")
    ("h" org-jira-get-issues-headonly "get all heads")
    ("v" org-jira-get-issues-by-board "get by board")
    ("f" org-jira-get-issues-by-fixversion "get by fixversion")
    ("r" org-jira-refresh-issue "refresh")
    ("R" org-jira-refresh-issues-in-buffer "refresh all")
    ("b" org-jira-browse-issue "browse")
    ("a" org-jira-assign-issue "assign")
    ("k" org-jira-copy-current-issue-key "copy key")
    ("w" org-jira-progress-issue "progress")
    ("n" org-jira-progress-issue-next "progress next")
    ("u" org-jira-update-issue "update")
    ("c" org-jira-create-issue "create"))

  (defhydra hydra-org-jira-comment (:exit t)
    "Org-jira comment"
    ("c" org-jira-add-comment "add")
    ("u" org-jira-update-comment "update"))

  (defhydra hydra-org-jira-subtask (:exit t)
    "Org-jira subtask"
    ("c" org-jira-create-subtask "create")
    ("g" org-jira-get-subtasks "refresh"))

  (defhydra hydra-org-jira-todo (:exit t)
    "Org-jira todo"
    ("j" org-jira-todo-to-jira "update from todo"))

  (defhydra hydra-org-jira-worklog (:exit t)
    "Org-jira worklog"
    ("u" org-jira-update-worklogs-from-org-clocks "update from org clocks"))


  (defhydra hydra-org-jira (org-jira-entry-mode-map "C-c j")
    "Org-jira"
    ("p" hydra-org-jira-project/body "project" :color blue)
    ("b" hydra-org-jira-board/body "board" :color blue)
    ("i" hydra-org-jira-issue/body "issue" :color blue)
    ("c" hydra-org-jira-comment/body "comment" :color blue)
    ("s" hydra-org-jira-subtask/body "subtask" :color blue)
    ("t" hydra-org-jira-todo/body "todo" :color blue)
    ("w" hydra-org-jira-worklog/body "worklog" :color blue))

  (define-key org-mode-map (kbd "C-c j") 'hydra-org-jira/body))
#+END_SRC

** debug
#+BEGIN_SRC emacs-lisp
(progn
  (require 'debug)
  (defhydra hydra-elisp (:exit t :hint nil)
    "
^Debug^
^-----^
on _e_ntry
"
    ("e" debug-on-entry))

  (define-key emacs-lisp-mode-map (kbd "C-c e") 'hydra-elisp/body)

  (defhydra hydra-elisp-debug (:post (quit-windows-on "*Backtrace*")
:hint nil)
    "
_c_ontinue  j_u_mp    _e_val
_s_tep      _l_ocals  _f_rame        _t_oggle-debug-on-error
_r_eturn    r_e_cord  _c_lear frame  _q_uit
"
    ("c" debugger-continue)
    ("s" debugger-step-through)
    ("r" debugger-return-value)

    ("u" debugger-jump)
    ("l" debugger-toggle-locals)
    ("e" debugger-record-expression)

    ("e" debugger-eval-expression)
    ("f" debugger-frame)
    ("c" debugger-frame-clear)

    ("t" toggle-debug-on-error)
    ("q" nil)
    )

  (define-key debugger-mode-map (kbd "?") 'hydra-elisp-debug/body)
  (add-hook 'debugger-mode-hook #'hydra-elisp-debug/body))
#+END_SRC

* Work
#+BEGIN_SRC emacs-lisp
(progn
  (setq openmail-project-root (expand-file-name "~/Projects/OpenMail/OpenMail/"))
  (add-to-list 'load-path (concat openmail-project-root "tools/emacs/"))

  (require 'openmail nil t)

  (require 'etl-mode nil t)

  (when (require 'etljenkins-mode nil t)
    (setq etljenkins-mode-groovy-root (concat openmail-project-root "etl/jenkins/")))

  (when (require 'sanitycheck-mode nil t)
    (setq sanitycheck-mode-compiler (concat openmail-project-root "etl/sanity_check_script.py")))
  (require 'ob-sanitycheck nil t)

  (when (require 'copydata-mode nil t)
    (setq copydata-mode-compiler (concat openmail-project-root "etl/copy_data.py")))
  (require 'ob-copydata nil t)

  (require 'ob-sqlplus nil t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setenv "PGCONNECT_TIMEOUT" "5")
#+END_SRC

